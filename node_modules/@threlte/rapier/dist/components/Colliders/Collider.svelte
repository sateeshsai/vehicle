<script>import { ActiveCollisionTypes, CoefficientCombineRule, Collider, ColliderDesc } from '@dimforge/rapier3d-compat';
import { createRawEventDispatcher, SceneGraphObject, useFrame } from '@threlte/core';
import { onDestroy, onMount, tick } from 'svelte';
import { Object3D, Quaternion, Vector3 } from 'three';
import { useCollisionGroups } from '../../hooks/useCollisionGroups';
import { useHasEventListeners } from '../../hooks/useHasEventListener';
import { useRapier } from '../../hooks/useRapier';
import { useRigidBody } from '../../hooks/useRigidBody';
import { applyColliderActiveEvents } from '../../lib/applyColliderActiveEvents';
import { eulerToQuaternion } from '../../lib/eulerToQuaternion';
import { getWorldPosition, getWorldQuaternion } from '../../lib/getWorldTransforms';
import { scaleColliderArgs } from '../../lib/scaleColliderArgs';
export let shape;
export let args;
export let type = undefined;
export let restitution = undefined;
export let restitutionCombineRule = undefined;
export let friction = undefined;
export let frictionCombineRule = undefined;
export let sensor = undefined;
export let contactForceEventThreshold = undefined;
export let density = undefined;
export let mass = undefined;
export let centerOfMass = undefined;
export let principalAngularInertia = undefined;
export let angularInertiaLocalFrame = undefined;
const object = new Object3D();
const rigidBody = useRigidBody();
const hasRigidBodyParent = !!rigidBody;
const rapierContext = useRapier();
const { world } = rapierContext;
export let collider = undefined;
const collisionGroups = useCollisionGroups();
const dispatcher = createRawEventDispatcher();
/**
 * Actual collider setup happens onMount as only then
 * the transforms are finished.
 */
onMount(async () => {
    await tick();
    const scale = object.getWorldScale(new Vector3());
    const scaledArgs = scaleColliderArgs(shape, args, scale);
    // @ts-ignore
    const colliderDesc = ColliderDesc[shape](...scaledArgs);
    collider = world.createCollider(colliderDesc, rigidBody);
    /**
     * Add collider to context
     */
    rapierContext.addColliderToContext(collider, object, dispatcher);
    /**
     * For use in conjunction with component <CollisionGroups>
     */
    collisionGroups.registerColliders([collider]);
    if (hasRigidBodyParent) {
        const rigidBodyWorldPos = new Vector3();
        const rigidBodyWorldQuatInversed = new Quaternion();
        object.traverseAncestors((child) => {
            if (child.userData.isRigidBody) {
                child.getWorldPosition(rigidBodyWorldPos);
                child.getWorldQuaternion(rigidBodyWorldQuatInversed);
                rigidBodyWorldQuatInversed.invert();
            }
        });
        const worldPosition = object.getWorldPosition(new Vector3()).sub(rigidBodyWorldPos);
        const worldRotation = object
            .getWorldQuaternion(new Quaternion())
            .premultiply(rigidBodyWorldQuatInversed);
        collider.setTranslationWrtParent(worldPosition);
        collider.setRotationWrtParent(worldRotation);
    }
    else {
        collider.setTranslation(object.getWorldPosition(new Vector3()));
        collider.setRotation(object.getWorldQuaternion(new Quaternion()));
    }
});
const { hasEventListeners: colliderHasEventListeners } = useHasEventListeners();
$: {
    if (collider) {
        applyColliderActiveEvents(collider, colliderHasEventListeners, rigidBody?.userData?.hasEventListeners);
        collider.setActiveCollisionTypes(ActiveCollisionTypes.ALL);
        collider.setRestitution(restitution ?? 0);
        collider.setContactForceEventThreshold(1);
        collider.setRestitutionCombineRule(restitutionCombineRule ?? CoefficientCombineRule.Average);
        collider.setFriction(friction ?? 0.7);
        collider.setFrictionCombineRule(frictionCombineRule ?? CoefficientCombineRule.Average);
        collider.setSensor(sensor ?? false);
        collider.setContactForceEventThreshold(contactForceEventThreshold ?? 0);
        if (density)
            collider.setDensity(density);
        if (mass) {
            if (centerOfMass && principalAngularInertia && angularInertiaLocalFrame) {
                collider.setMassProperties(mass, { x: centerOfMass[0], y: centerOfMass[1], z: centerOfMass[2] }, {
                    x: principalAngularInertia[0],
                    y: principalAngularInertia[1],
                    z: principalAngularInertia[2]
                }, eulerToQuaternion(angularInertiaLocalFrame));
            }
            else {
                collider.setMass(mass);
            }
        }
    }
}
export const refresh = () => {
    if (!collider)
        return;
    collider.setTranslation(getWorldPosition(object));
    collider.setRotation(getWorldQuaternion(object));
};
/**
 * If the Collider isAttached (i.e. NOT child of a RigidBody), update the
 * transforms on every frame.
 */
const { start, stop } = useFrame(() => {
    refresh();
}, {
    autostart: !hasRigidBodyParent && type === 'dynamic'
});
$: {
    if (!hasRigidBodyParent && type === 'dynamic')
        start();
    else
        stop();
}
/**
 * Cleanup
 */
onDestroy(() => {
    if (!collider)
        return;
    rapierContext.removeColliderFromContext(collider);
    collisionGroups.removeColliders([collider]);
    world.removeCollider(collider, true);
    collider = undefined;
});
</script>

<SceneGraphObject {object}>
  <slot {collider} />
</SceneGraphObject>
