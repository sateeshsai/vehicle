import {
  FA,
  KA,
  PI,
  RI,
  SA,
  UA,
  dI,
  nA,
  qI
} from "./chunk-SILEJBRW.js";
import {
  SceneGraphObject_default,
  T,
  createRawEventDispatcher,
  useFrame,
  useThrelte
} from "./chunk-XDVD47K7.js";
import "./chunk-6A2TAOKG.js";
import {
  BufferAttribute,
  BufferGeometry,
  Euler,
  Group,
  Object3D,
  Quaternion,
  Vector2,
  Vector3
} from "./chunk-ADRZNPHV.js";
import {
  derived,
  readable,
  writable
} from "./chunk-6NUSVQJM.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  assign,
  bind,
  binding_callbacks,
  check_outros,
  claim_component,
  claim_space,
  component_subscribe,
  compute_rest_props,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  onDestroy,
  onMount,
  prevent_default,
  run_all,
  safe_not_equal,
  setContext,
  set_store_value,
  space,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-CKECMU6L.js";
import "./chunk-Y4AOG3KG.js";

// node_modules/@threlte/rapier/dist/hooks/useRapier.js
var useRapier = () => {
  return getContext("threlte-rapier-context");
};

// node_modules/@threlte/rapier/dist/hooks/useCollisionGroups.js
var applyBitMask = (collidersMap, bitMask) => {
  collidersMap.forEach((c) => {
    if (c && c.collider && c.collider.isValid()) {
      c.collider.setCollisionGroups(bitMask);
    }
  });
};
var useCollisionGroups = () => {
  const collidersMap = /* @__PURE__ */ new Map();
  const bitMaskStore = getContext("threlte-rapier-collision-group");
  if (!bitMaskStore)
    return {
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      registerColliders: (colliders) => {
      },
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      removeColliders: (colliders) => {
      }
    };
  let bitMask = get_store_value(bitMaskStore);
  const unsubscribe = bitMaskStore.subscribe((newBitMask) => {
    bitMask = newBitMask;
    applyBitMask(collidersMap, newBitMask);
  });
  onDestroy(unsubscribe);
  const registerColliders = (colliders) => {
    colliders.forEach((c) => {
      if (!collidersMap.has(c.handle)) {
        collidersMap.set(c.handle, {
          collider: c,
          initialCollisionGroup: c.collisionGroups()
        });
      }
    });
    applyBitMask(collidersMap, bitMask);
  };
  const removeColliders = (colliders) => {
    colliders.forEach((c) => {
      const mapItem = collidersMap.get(c.handle);
      if (mapItem) {
        if (c && c.isValid()) {
          c.setCollisionGroups(mapItem.initialCollisionGroup);
        }
      }
      collidersMap.delete(c.handle);
    });
  };
  return {
    registerColliders,
    removeColliders
  };
};

// node_modules/@threlte/rapier/dist/hooks/useRigidBody.js
var useRigidBody = () => {
  return getContext("threlte-rapier-rigidbody");
};

// node_modules/@threlte/rapier/dist/hooks/useJoint.js
var useJoint = (initializeJoint) => {
  const rigidBodyA = writable(void 0);
  const rigidBodyB = writable(void 0);
  const ctx = useRapier();
  const bodies = derived([rigidBodyA, rigidBodyB], ([rbA, rbB]) => {
    if (!!rbA && !!rbB) {
      return [rbA, rbB];
    }
  });
  const joint = writable(void 0);
  const unsubscribeBodies = bodies.subscribe((bodies2) => {
    if (bodies2)
      joint.set(initializeJoint(...bodies2, ctx));
  });
  onDestroy(() => {
    unsubscribeBodies();
    const j = get_store_value(joint);
    if (!j)
      return;
    if (j instanceof nA) {
      ctx.world.removeMultibodyJoint(j, true);
    } else {
      ctx.world.removeImpulseJoint(j, true);
    }
  });
  return {
    joint,
    rigidBodyA,
    rigidBodyB
  };
};

// node_modules/@threlte/rapier/dist/hooks/useRevoluteJoint.js
var useRevoluteJoint = (anchorA, anchorB, axis, limits) => {
  return useJoint((rbA, rbB, { world, rapier }) => {
    const jaA = anchorA instanceof Vector3 ? anchorA : new Vector3(...anchorA);
    const jaB = anchorB instanceof Vector3 ? anchorB : new Vector3(...anchorB);
    const jAxis = (axis instanceof Vector3 ? axis : new Vector3(...axis)).normalize();
    const params = rapier.JointData.revolute(jaA, jaB, jAxis);
    if (limits) {
      params.limitsEnabled = true;
      params.limits = limits;
    }
    return world.createImpulseJoint(params, rbA, rbB, true);
  });
};

// node_modules/@threlte/rapier/dist/hooks/usePrismaticJoint.js
var usePrismaticJoint = (anchorA, anchorB, axis, limits) => {
  return useJoint((rbA, rbB, { world, rapier }) => {
    const jaA = anchorA instanceof Vector3 ? anchorA : new Vector3(...anchorA);
    const jaB = anchorB instanceof Vector3 ? anchorB : new Vector3(...anchorB);
    const jAxis = (axis instanceof Vector3 ? axis : new Vector3(...axis)).normalize();
    const params = rapier.JointData.prismatic(jaA, jaB, jAxis);
    if (limits) {
      params.limitsEnabled = true;
      params.limits = limits;
    }
    return world.createImpulseJoint(params, rbA, rbB, true);
  });
};

// node_modules/@threlte/rapier/dist/hooks/useFixedJoint.js
var useFixedJoint = (anchorA, frameA, anchorB, frameB) => {
  const jaA = anchorA instanceof Vector3 ? anchorA : new Vector3(...anchorA);
  const jfA = new Quaternion().setFromEuler(frameA instanceof Euler ? frameA : new Euler(...frameA));
  const jaB = anchorB instanceof Vector3 ? anchorB : new Vector3(...anchorB);
  const jfB = new Quaternion().setFromEuler(frameB instanceof Euler ? frameB : new Euler(...frameB));
  return useJoint((rbA, rbB, { world, rapier }) => {
    const params = rapier.JointData.fixed(jaA, jfA, jaB, jfB);
    return world.createImpulseJoint(params, rbA, rbB, true);
  });
};

// node_modules/@threlte/rapier/dist/hooks/useSphericalJoint.js
var useSphericalJoint = (anchorA, anchorB) => {
  return useJoint((rbA, rbB, { world, rapier }) => {
    const jaA = anchorA instanceof Vector3 ? anchorA : new Vector3(...anchorA);
    const jaB = anchorB instanceof Vector3 ? anchorB : new Vector3(...anchorB);
    const params = rapier.JointData.spherical(jaA, jaB);
    return world.createImpulseJoint(params, rbA, rbB, true);
  });
};

// node_modules/@threlte/rapier/dist/lib/createRapierContext.js
var createRapierContext = (...args) => {
  const world = new PI.World(...args);
  const colliderObjects = /* @__PURE__ */ new Map();
  const rigidBodyObjects = /* @__PURE__ */ new Map();
  const rigidBodyEventDispatchers = /* @__PURE__ */ new Map();
  const colliderEventDispatchers = /* @__PURE__ */ new Map();
  const addColliderToContext = (collider, object, eventDispatcher) => {
    colliderObjects.set(collider.handle, object);
    colliderEventDispatchers.set(collider.handle, eventDispatcher);
  };
  const removeColliderFromContext = (collider) => {
    colliderObjects.delete(collider.handle);
    colliderEventDispatchers.delete(collider.handle);
  };
  const addRigidBodyToContext = (rigidBody, object, eventDispatcher) => {
    rigidBodyObjects.set(rigidBody.handle, object);
    rigidBodyEventDispatchers.set(rigidBody.handle, eventDispatcher);
  };
  const removeRigidBodyFromContext = (rigidBody) => {
    rigidBodyObjects.delete(rigidBody.handle);
    rigidBodyEventDispatchers.delete(rigidBody.handle);
  };
  const pause = () => {
  };
  const resume = () => {
  };
  return {
    rapier: PI,
    world,
    colliderObjects,
    rigidBodyObjects,
    rigidBodyEventDispatchers,
    colliderEventDispatchers,
    addColliderToContext,
    removeColliderFromContext,
    addRigidBodyToContext,
    removeRigidBodyFromContext,
    debug: writable(false),
    pause,
    resume,
    paused: readable(false)
  };
};

// node_modules/@threlte/rapier/dist/hooks/useFrameHandler.js
var tempObject = new Object3D();
var tempVector3 = new Vector3();
var tempQuaternion = new Quaternion();
var getEventDispatchers = (ctx, collider1, collider2) => {
  const colliderDispatcher1 = ctx.colliderEventDispatchers.get(collider1.handle);
  const colliderDispatcher2 = ctx.colliderEventDispatchers.get(collider2.handle);
  const rigidBody1 = collider1.parent();
  const rigidBody2 = collider2.parent();
  const rigidBodyDispatcher1 = rigidBody1 ? ctx.rigidBodyEventDispatchers.get(rigidBody1.handle) : void 0;
  const rigidBodyDispatcher2 = rigidBody2 ? ctx.rigidBodyEventDispatchers.get(rigidBody2.handle) : void 0;
  return {
    colliderDispatcher1,
    colliderDispatcher2,
    rigidBodyDispatcher1,
    rigidBodyDispatcher2
  };
};
var useFrameHandler = (ctx, order) => {
  const eventQueue = new dI(false);
  const { start, started, stop } = useFrame((_, delta) => {
    const { world } = ctx;
    world.timestep = Math.min(0.1, delta);
    world.step(eventQueue);
    ctx.rigidBodyObjects.forEach((mesh, handle) => {
      const rigidBody = world.getRigidBody(handle);
      if (!rigidBody)
        return;
      const dispatcher = ctx.rigidBodyEventDispatchers.get(handle);
      if (!rigidBody || !rigidBody.isValid())
        return;
      if (dispatcher) {
        if (rigidBody.isSleeping() && !mesh.userData.isSleeping) {
          dispatcher("sleep");
        }
        if (!rigidBody.isSleeping() && mesh.userData.isSleeping) {
          dispatcher("wake");
        }
        mesh.userData.isSleeping = rigidBody.isSleeping();
      }
      if (!rigidBody || rigidBody.isSleeping() || rigidBody.isFixed() || !mesh.parent) {
        return;
      }
      const { x, y, z } = rigidBody.translation();
      tempObject.position.set(x, y, z);
      const rotation = rigidBody.rotation();
      tempQuaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
      tempObject.rotation.setFromQuaternion(tempQuaternion);
      mesh.getWorldScale(tempVector3);
      tempObject.scale.copy(tempVector3);
      tempObject.updateMatrix();
      tempObject.applyMatrix4(mesh.parent.matrixWorld.clone().invert());
      tempObject.updateMatrix();
      mesh.position.setFromMatrixPosition(tempObject.matrix);
      mesh.rotation.setFromRotationMatrix(tempObject.matrix);
    });
    eventQueue.drainContactForceEvents((e2) => {
      const collider1 = world.getCollider(e2.collider1());
      const collider2 = world.getCollider(e2.collider2());
      if (!collider1 || !collider2) {
        return;
      }
      const { colliderDispatcher1, colliderDispatcher2, rigidBodyDispatcher1, rigidBodyDispatcher2 } = getEventDispatchers(ctx, collider1, collider2);
      const rigidBody1 = collider1.parent();
      const rigidBody2 = collider2.parent();
      colliderDispatcher1 == null ? void 0 : colliderDispatcher1("contact", {
        targetCollider: collider2,
        targetRigidBody: rigidBody2,
        maxForceDirection: e2.maxForceDirection(),
        maxForceMagnitude: e2.maxForceMagnitude(),
        totalForce: e2.totalForce(),
        totalForceMagnitude: e2.totalForceMagnitude()
      });
      colliderDispatcher2 == null ? void 0 : colliderDispatcher2("contact", {
        targetCollider: collider1,
        targetRigidBody: rigidBody1,
        maxForceDirection: e2.maxForceDirection(),
        maxForceMagnitude: e2.maxForceMagnitude(),
        totalForce: e2.totalForce(),
        totalForceMagnitude: e2.totalForceMagnitude()
      });
      rigidBodyDispatcher1 == null ? void 0 : rigidBodyDispatcher1("contact", {
        targetCollider: collider2,
        targetRigidBody: rigidBody2,
        maxForceDirection: e2.maxForceDirection(),
        maxForceMagnitude: e2.maxForceMagnitude(),
        totalForce: e2.totalForce(),
        totalForceMagnitude: e2.totalForceMagnitude()
      });
      rigidBodyDispatcher2 == null ? void 0 : rigidBodyDispatcher2("contact", {
        targetCollider: collider1,
        targetRigidBody: rigidBody1,
        maxForceDirection: e2.maxForceDirection(),
        maxForceMagnitude: e2.maxForceMagnitude(),
        totalForce: e2.totalForce(),
        totalForceMagnitude: e2.totalForceMagnitude()
      });
    });
    eventQueue.drainCollisionEvents((handle1, handle2, started2) => {
      const collider1 = world.getCollider(handle1);
      const collider2 = world.getCollider(handle2);
      if (!collider1 || !collider2) {
        return;
      }
      const { colliderDispatcher1, colliderDispatcher2, rigidBodyDispatcher1, rigidBodyDispatcher2 } = getEventDispatchers(ctx, collider1, collider2);
      const rigidBody1 = collider1.parent();
      const rigidBody2 = collider2.parent();
      if (started2) {
        const isIntersection = world.intersectionPair(collider1, collider2);
        if (isIntersection) {
          colliderDispatcher1 == null ? void 0 : colliderDispatcher1("sensorenter", {
            targetCollider: collider2,
            targetRigidBody: rigidBody2
          });
          colliderDispatcher2 == null ? void 0 : colliderDispatcher2("sensorenter", {
            targetCollider: collider1,
            targetRigidBody: rigidBody1
          });
          rigidBodyDispatcher1 == null ? void 0 : rigidBodyDispatcher1("sensorenter", {
            targetCollider: collider2,
            targetRigidBody: rigidBody2
          });
          rigidBodyDispatcher2 == null ? void 0 : rigidBodyDispatcher2("sensorenter", {
            targetCollider: collider1,
            targetRigidBody: rigidBody1
          });
          return;
        }
        world.contactPair(collider1, collider2, (manifold, flipped) => {
          colliderDispatcher1 == null ? void 0 : colliderDispatcher1("collisionenter", {
            flipped,
            manifold,
            targetCollider: collider2,
            targetRigidBody: rigidBody2
          });
          colliderDispatcher2 == null ? void 0 : colliderDispatcher2("collisionenter", {
            flipped,
            manifold,
            targetCollider: collider1,
            targetRigidBody: rigidBody1
          });
          rigidBodyDispatcher1 == null ? void 0 : rigidBodyDispatcher1("collisionenter", {
            flipped,
            manifold,
            targetCollider: collider2,
            targetRigidBody: rigidBody2
          });
          rigidBodyDispatcher2 == null ? void 0 : rigidBodyDispatcher2("collisionenter", {
            flipped,
            manifold,
            targetCollider: collider1,
            targetRigidBody: rigidBody1
          });
        });
      } else {
        const isIntersection = world.intersectionPair(collider1, collider2) || collider1.isSensor() || collider2.isSensor();
        if (isIntersection) {
          colliderDispatcher1 == null ? void 0 : colliderDispatcher1("sensorexit", {
            targetCollider: collider2,
            targetRigidBody: rigidBody2
          });
          colliderDispatcher2 == null ? void 0 : colliderDispatcher2("sensorexit", {
            targetCollider: collider1,
            targetRigidBody: rigidBody1
          });
          rigidBodyDispatcher1 == null ? void 0 : rigidBodyDispatcher1("sensorexit", {
            targetCollider: collider2,
            targetRigidBody: rigidBody2
          });
          rigidBodyDispatcher2 == null ? void 0 : rigidBodyDispatcher2("sensorexit", {
            targetCollider: collider1,
            targetRigidBody: rigidBody1
          });
          return;
        }
        colliderDispatcher1 == null ? void 0 : colliderDispatcher1("collisionexit", {
          targetCollider: collider2,
          targetRigidBody: rigidBody2
        });
        colliderDispatcher2 == null ? void 0 : colliderDispatcher2("collisionexit", {
          targetCollider: collider1,
          targetRigidBody: rigidBody1
        });
        rigidBodyDispatcher1 == null ? void 0 : rigidBodyDispatcher1("collisionexit", {
          targetCollider: collider2,
          targetRigidBody: rigidBody2
        });
        rigidBodyDispatcher2 == null ? void 0 : rigidBodyDispatcher2("collisionexit", {
          targetCollider: collider1,
          targetRigidBody: rigidBody1
        });
      }
    });
  }, { order });
  ctx.pause = () => stop();
  ctx.resume = () => start();
  ctx.paused = derived(started, (started2) => !started2);
};

// node_modules/@threlte/rapier/dist/components/World/InnerWorld.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InnerWorld", slots, ["default"]);
  let { gravity = [0, -9.81, 0] } = $$props;
  let { rawIntegrationParameters = void 0 } = $$props;
  let { rawIslands = void 0 } = $$props;
  let { rawBroadPhase = void 0 } = $$props;
  let { rawNarrowPhase = void 0 } = $$props;
  let { rawBodies = void 0 } = $$props;
  let { rawColliders = void 0 } = $$props;
  let { rawImpulseJoints = void 0 } = $$props;
  let { rawMultibodyJoints = void 0 } = $$props;
  let { rawCCDSolver = void 0 } = $$props;
  let { rawQueryPipeline = void 0 } = $$props;
  let { rawPhysicsPipeline = void 0 } = $$props;
  let { rawSerializationPipeline = void 0 } = $$props;
  let { rawDebugRenderPipeline = void 0 } = $$props;
  let { order = void 0 } = $$props;
  const rapierContext = createRapierContext(
    {
      x: gravity[0],
      y: gravity[1],
      z: gravity[2]
    },
    rawIntegrationParameters,
    rawIslands,
    rawBroadPhase,
    rawNarrowPhase,
    rawBodies,
    rawColliders,
    rawImpulseJoints,
    rawMultibodyJoints,
    rawCCDSolver,
    rawQueryPipeline,
    rawPhysicsPipeline,
    rawSerializationPipeline,
    rawDebugRenderPipeline
  );
  setContext("threlte-rapier-context", rapierContext);
  useFrameHandler(rapierContext, order);
  onDestroy(async () => {
    await tick();
    rapierContext.world.free();
  });
  const writable_props = [
    "gravity",
    "rawIntegrationParameters",
    "rawIslands",
    "rawBroadPhase",
    "rawNarrowPhase",
    "rawBodies",
    "rawColliders",
    "rawImpulseJoints",
    "rawMultibodyJoints",
    "rawCCDSolver",
    "rawQueryPipeline",
    "rawPhysicsPipeline",
    "rawSerializationPipeline",
    "rawDebugRenderPipeline",
    "order"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InnerWorld> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("gravity" in $$props2)
      $$invalidate(0, gravity = $$props2.gravity);
    if ("rawIntegrationParameters" in $$props2)
      $$invalidate(1, rawIntegrationParameters = $$props2.rawIntegrationParameters);
    if ("rawIslands" in $$props2)
      $$invalidate(2, rawIslands = $$props2.rawIslands);
    if ("rawBroadPhase" in $$props2)
      $$invalidate(3, rawBroadPhase = $$props2.rawBroadPhase);
    if ("rawNarrowPhase" in $$props2)
      $$invalidate(4, rawNarrowPhase = $$props2.rawNarrowPhase);
    if ("rawBodies" in $$props2)
      $$invalidate(5, rawBodies = $$props2.rawBodies);
    if ("rawColliders" in $$props2)
      $$invalidate(6, rawColliders = $$props2.rawColliders);
    if ("rawImpulseJoints" in $$props2)
      $$invalidate(7, rawImpulseJoints = $$props2.rawImpulseJoints);
    if ("rawMultibodyJoints" in $$props2)
      $$invalidate(8, rawMultibodyJoints = $$props2.rawMultibodyJoints);
    if ("rawCCDSolver" in $$props2)
      $$invalidate(9, rawCCDSolver = $$props2.rawCCDSolver);
    if ("rawQueryPipeline" in $$props2)
      $$invalidate(10, rawQueryPipeline = $$props2.rawQueryPipeline);
    if ("rawPhysicsPipeline" in $$props2)
      $$invalidate(11, rawPhysicsPipeline = $$props2.rawPhysicsPipeline);
    if ("rawSerializationPipeline" in $$props2)
      $$invalidate(12, rawSerializationPipeline = $$props2.rawSerializationPipeline);
    if ("rawDebugRenderPipeline" in $$props2)
      $$invalidate(13, rawDebugRenderPipeline = $$props2.rawDebugRenderPipeline);
    if ("order" in $$props2)
      $$invalidate(14, order = $$props2.order);
    if ("$$scope" in $$props2)
      $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    setContext,
    tick,
    useFrameHandler,
    createRapierContext,
    gravity,
    rawIntegrationParameters,
    rawIslands,
    rawBroadPhase,
    rawNarrowPhase,
    rawBodies,
    rawColliders,
    rawImpulseJoints,
    rawMultibodyJoints,
    rawCCDSolver,
    rawQueryPipeline,
    rawPhysicsPipeline,
    rawSerializationPipeline,
    rawDebugRenderPipeline,
    order,
    rapierContext
  });
  $$self.$inject_state = ($$props2) => {
    if ("gravity" in $$props2)
      $$invalidate(0, gravity = $$props2.gravity);
    if ("rawIntegrationParameters" in $$props2)
      $$invalidate(1, rawIntegrationParameters = $$props2.rawIntegrationParameters);
    if ("rawIslands" in $$props2)
      $$invalidate(2, rawIslands = $$props2.rawIslands);
    if ("rawBroadPhase" in $$props2)
      $$invalidate(3, rawBroadPhase = $$props2.rawBroadPhase);
    if ("rawNarrowPhase" in $$props2)
      $$invalidate(4, rawNarrowPhase = $$props2.rawNarrowPhase);
    if ("rawBodies" in $$props2)
      $$invalidate(5, rawBodies = $$props2.rawBodies);
    if ("rawColliders" in $$props2)
      $$invalidate(6, rawColliders = $$props2.rawColliders);
    if ("rawImpulseJoints" in $$props2)
      $$invalidate(7, rawImpulseJoints = $$props2.rawImpulseJoints);
    if ("rawMultibodyJoints" in $$props2)
      $$invalidate(8, rawMultibodyJoints = $$props2.rawMultibodyJoints);
    if ("rawCCDSolver" in $$props2)
      $$invalidate(9, rawCCDSolver = $$props2.rawCCDSolver);
    if ("rawQueryPipeline" in $$props2)
      $$invalidate(10, rawQueryPipeline = $$props2.rawQueryPipeline);
    if ("rawPhysicsPipeline" in $$props2)
      $$invalidate(11, rawPhysicsPipeline = $$props2.rawPhysicsPipeline);
    if ("rawSerializationPipeline" in $$props2)
      $$invalidate(12, rawSerializationPipeline = $$props2.rawSerializationPipeline);
    if ("rawDebugRenderPipeline" in $$props2)
      $$invalidate(13, rawDebugRenderPipeline = $$props2.rawDebugRenderPipeline);
    if ("order" in $$props2)
      $$invalidate(14, order = $$props2.order);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*gravity*/
    1) {
      $:
        if (gravity !== void 0) {
          rapierContext.world.gravity = {
            x: gravity[0],
            y: gravity[1],
            z: gravity[2]
          };
        }
    }
  };
  return [
    gravity,
    rawIntegrationParameters,
    rawIslands,
    rawBroadPhase,
    rawNarrowPhase,
    rawBodies,
    rawColliders,
    rawImpulseJoints,
    rawMultibodyJoints,
    rawCCDSolver,
    rawQueryPipeline,
    rawPhysicsPipeline,
    rawSerializationPipeline,
    rawDebugRenderPipeline,
    order,
    $$scope,
    slots
  ];
}
var InnerWorld = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      gravity: 0,
      rawIntegrationParameters: 1,
      rawIslands: 2,
      rawBroadPhase: 3,
      rawNarrowPhase: 4,
      rawBodies: 5,
      rawColliders: 6,
      rawImpulseJoints: 7,
      rawMultibodyJoints: 8,
      rawCCDSolver: 9,
      rawQueryPipeline: 10,
      rawPhysicsPipeline: 11,
      rawSerializationPipeline: 12,
      rawDebugRenderPipeline: 13,
      order: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InnerWorld",
      options,
      id: create_fragment.name
    });
  }
  get gravity() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gravity(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawIntegrationParameters() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawIntegrationParameters(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawIslands() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawIslands(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawBroadPhase() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawBroadPhase(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawNarrowPhase() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawNarrowPhase(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawBodies() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawBodies(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawColliders() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawColliders(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawImpulseJoints() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawImpulseJoints(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawMultibodyJoints() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawMultibodyJoints(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawCCDSolver() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawCCDSolver(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawQueryPipeline() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawQueryPipeline(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawPhysicsPipeline() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawPhysicsPipeline(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawSerializationPipeline() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawSerializationPipeline(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawDebugRenderPipeline() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawDebugRenderPipeline(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get order() {
    throw new Error("<InnerWorld>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set order(value) {
    throw new Error("<InnerWorld>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InnerWorld_default = InnerWorld;

// node_modules/@threlte/rapier/dist/components/World/World.svelte
var get_fallback_slot_changes = (dirty) => ({});
var get_fallback_slot_context = (ctx) => ({});
function create_if_block_1(ctx) {
  let innerworld;
  let current;
  innerworld = new InnerWorld_default({
    props: {
      gravity: (
        /*gravity*/
        ctx[0]
      ),
      rawIntegrationParameters: (
        /*rawIntegrationParameters*/
        ctx[1]
      ),
      rawIslands: (
        /*rawIslands*/
        ctx[2]
      ),
      rawBroadPhase: (
        /*rawBroadPhase*/
        ctx[3]
      ),
      rawNarrowPhase: (
        /*rawNarrowPhase*/
        ctx[4]
      ),
      rawBodies: (
        /*rawBodies*/
        ctx[5]
      ),
      rawColliders: (
        /*rawColliders*/
        ctx[6]
      ),
      rawImpulseJoints: (
        /*rawImpulseJoints*/
        ctx[7]
      ),
      rawMultibodyJoints: (
        /*rawMultibodyJoints*/
        ctx[8]
      ),
      rawCCDSolver: (
        /*rawCCDSolver*/
        ctx[9]
      ),
      rawQueryPipeline: (
        /*rawQueryPipeline*/
        ctx[10]
      ),
      rawPhysicsPipeline: (
        /*rawPhysicsPipeline*/
        ctx[11]
      ),
      rawSerializationPipeline: (
        /*rawSerializationPipeline*/
        ctx[12]
      ),
      rawDebugRenderPipeline: (
        /*rawDebugRenderPipeline*/
        ctx[13]
      ),
      order: (
        /*order*/
        ctx[14]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(innerworld.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(innerworld.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(innerworld, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const innerworld_changes = {};
      if (dirty & /*gravity*/
      1)
        innerworld_changes.gravity = /*gravity*/
        ctx2[0];
      if (dirty & /*rawIntegrationParameters*/
      2)
        innerworld_changes.rawIntegrationParameters = /*rawIntegrationParameters*/
        ctx2[1];
      if (dirty & /*rawIslands*/
      4)
        innerworld_changes.rawIslands = /*rawIslands*/
        ctx2[2];
      if (dirty & /*rawBroadPhase*/
      8)
        innerworld_changes.rawBroadPhase = /*rawBroadPhase*/
        ctx2[3];
      if (dirty & /*rawNarrowPhase*/
      16)
        innerworld_changes.rawNarrowPhase = /*rawNarrowPhase*/
        ctx2[4];
      if (dirty & /*rawBodies*/
      32)
        innerworld_changes.rawBodies = /*rawBodies*/
        ctx2[5];
      if (dirty & /*rawColliders*/
      64)
        innerworld_changes.rawColliders = /*rawColliders*/
        ctx2[6];
      if (dirty & /*rawImpulseJoints*/
      128)
        innerworld_changes.rawImpulseJoints = /*rawImpulseJoints*/
        ctx2[7];
      if (dirty & /*rawMultibodyJoints*/
      256)
        innerworld_changes.rawMultibodyJoints = /*rawMultibodyJoints*/
        ctx2[8];
      if (dirty & /*rawCCDSolver*/
      512)
        innerworld_changes.rawCCDSolver = /*rawCCDSolver*/
        ctx2[9];
      if (dirty & /*rawQueryPipeline*/
      1024)
        innerworld_changes.rawQueryPipeline = /*rawQueryPipeline*/
        ctx2[10];
      if (dirty & /*rawPhysicsPipeline*/
      2048)
        innerworld_changes.rawPhysicsPipeline = /*rawPhysicsPipeline*/
        ctx2[11];
      if (dirty & /*rawSerializationPipeline*/
      4096)
        innerworld_changes.rawSerializationPipeline = /*rawSerializationPipeline*/
        ctx2[12];
      if (dirty & /*rawDebugRenderPipeline*/
      8192)
        innerworld_changes.rawDebugRenderPipeline = /*rawDebugRenderPipeline*/
        ctx2[13];
      if (dirty & /*order*/
      16384)
        innerworld_changes.order = /*order*/
        ctx2[14];
      if (dirty & /*$$scope*/
      262144) {
        innerworld_changes.$$scope = { dirty, ctx: ctx2 };
      }
      innerworld.$set(innerworld_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(innerworld.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(innerworld.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(innerworld, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(50:0) {#if $initialized}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(51:2) <InnerWorld     {gravity}     {rawIntegrationParameters}     {rawIslands}     {rawBroadPhase}     {rawNarrowPhase}     {rawBodies}     {rawColliders}     {rawImpulseJoints}     {rawMultibodyJoints}     {rawCCDSolver}     {rawQueryPipeline}     {rawPhysicsPipeline}     {rawSerializationPipeline}     {rawDebugRenderPipeline}   {order}   >",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const fallback_slot_template = (
    /*#slots*/
    ctx[17].fallback
  );
  const fallback_slot = create_slot(
    fallback_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_fallback_slot_context
  );
  const block = {
    c: function create() {
      if (fallback_slot)
        fallback_slot.c();
    },
    l: function claim(nodes) {
      if (fallback_slot)
        fallback_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (fallback_slot) {
        fallback_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (fallback_slot) {
        if (fallback_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            fallback_slot,
            fallback_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              fallback_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_fallback_slot_changes
            ),
            get_fallback_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fallback_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fallback_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (fallback_slot)
        fallback_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(72:0) {#if error}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*$initialized*/
    ctx[16] && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*error*/
    ctx[15] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$initialized*/
        ctx2[16]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$initialized*/
          65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*error*/
        ctx2[15]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*error*/
          32768) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var initialized = writable(false);
function instance2($$self, $$props, $$invalidate) {
  let $initialized;
  validate_store(initialized, "initialized");
  component_subscribe($$self, initialized, ($$value) => $$invalidate(16, $initialized = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("World", slots, ["default", "fallback"]);
  let { gravity = void 0 } = $$props;
  let { rawIntegrationParameters = void 0 } = $$props;
  let { rawIslands = void 0 } = $$props;
  let { rawBroadPhase = void 0 } = $$props;
  let { rawNarrowPhase = void 0 } = $$props;
  let { rawBodies = void 0 } = $$props;
  let { rawColliders = void 0 } = $$props;
  let { rawImpulseJoints = void 0 } = $$props;
  let { rawMultibodyJoints = void 0 } = $$props;
  let { rawCCDSolver = void 0 } = $$props;
  let { rawQueryPipeline = void 0 } = $$props;
  let { rawPhysicsPipeline = void 0 } = $$props;
  let { rawSerializationPipeline = void 0 } = $$props;
  let { rawDebugRenderPipeline = void 0 } = $$props;
  let { order = void 0 } = $$props;
  let error = false;
  const init2 = async () => {
    if ($initialized)
      return;
    try {
      await PI.init();
      set_store_value(initialized, $initialized = true, $initialized);
    } catch (e2) {
      $$invalidate(15, error = true);
    }
  };
  onMount(init2);
  const writable_props = [
    "gravity",
    "rawIntegrationParameters",
    "rawIslands",
    "rawBroadPhase",
    "rawNarrowPhase",
    "rawBodies",
    "rawColliders",
    "rawImpulseJoints",
    "rawMultibodyJoints",
    "rawCCDSolver",
    "rawQueryPipeline",
    "rawPhysicsPipeline",
    "rawSerializationPipeline",
    "rawDebugRenderPipeline",
    "order"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<World> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("gravity" in $$props2)
      $$invalidate(0, gravity = $$props2.gravity);
    if ("rawIntegrationParameters" in $$props2)
      $$invalidate(1, rawIntegrationParameters = $$props2.rawIntegrationParameters);
    if ("rawIslands" in $$props2)
      $$invalidate(2, rawIslands = $$props2.rawIslands);
    if ("rawBroadPhase" in $$props2)
      $$invalidate(3, rawBroadPhase = $$props2.rawBroadPhase);
    if ("rawNarrowPhase" in $$props2)
      $$invalidate(4, rawNarrowPhase = $$props2.rawNarrowPhase);
    if ("rawBodies" in $$props2)
      $$invalidate(5, rawBodies = $$props2.rawBodies);
    if ("rawColliders" in $$props2)
      $$invalidate(6, rawColliders = $$props2.rawColliders);
    if ("rawImpulseJoints" in $$props2)
      $$invalidate(7, rawImpulseJoints = $$props2.rawImpulseJoints);
    if ("rawMultibodyJoints" in $$props2)
      $$invalidate(8, rawMultibodyJoints = $$props2.rawMultibodyJoints);
    if ("rawCCDSolver" in $$props2)
      $$invalidate(9, rawCCDSolver = $$props2.rawCCDSolver);
    if ("rawQueryPipeline" in $$props2)
      $$invalidate(10, rawQueryPipeline = $$props2.rawQueryPipeline);
    if ("rawPhysicsPipeline" in $$props2)
      $$invalidate(11, rawPhysicsPipeline = $$props2.rawPhysicsPipeline);
    if ("rawSerializationPipeline" in $$props2)
      $$invalidate(12, rawSerializationPipeline = $$props2.rawSerializationPipeline);
    if ("rawDebugRenderPipeline" in $$props2)
      $$invalidate(13, rawDebugRenderPipeline = $$props2.rawDebugRenderPipeline);
    if ("order" in $$props2)
      $$invalidate(14, order = $$props2.order);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    RAPIER: PI,
    onMount,
    writable,
    initialized,
    InnerWorld: InnerWorld_default,
    gravity,
    rawIntegrationParameters,
    rawIslands,
    rawBroadPhase,
    rawNarrowPhase,
    rawBodies,
    rawColliders,
    rawImpulseJoints,
    rawMultibodyJoints,
    rawCCDSolver,
    rawQueryPipeline,
    rawPhysicsPipeline,
    rawSerializationPipeline,
    rawDebugRenderPipeline,
    order,
    error,
    init: init2,
    $initialized
  });
  $$self.$inject_state = ($$props2) => {
    if ("gravity" in $$props2)
      $$invalidate(0, gravity = $$props2.gravity);
    if ("rawIntegrationParameters" in $$props2)
      $$invalidate(1, rawIntegrationParameters = $$props2.rawIntegrationParameters);
    if ("rawIslands" in $$props2)
      $$invalidate(2, rawIslands = $$props2.rawIslands);
    if ("rawBroadPhase" in $$props2)
      $$invalidate(3, rawBroadPhase = $$props2.rawBroadPhase);
    if ("rawNarrowPhase" in $$props2)
      $$invalidate(4, rawNarrowPhase = $$props2.rawNarrowPhase);
    if ("rawBodies" in $$props2)
      $$invalidate(5, rawBodies = $$props2.rawBodies);
    if ("rawColliders" in $$props2)
      $$invalidate(6, rawColliders = $$props2.rawColliders);
    if ("rawImpulseJoints" in $$props2)
      $$invalidate(7, rawImpulseJoints = $$props2.rawImpulseJoints);
    if ("rawMultibodyJoints" in $$props2)
      $$invalidate(8, rawMultibodyJoints = $$props2.rawMultibodyJoints);
    if ("rawCCDSolver" in $$props2)
      $$invalidate(9, rawCCDSolver = $$props2.rawCCDSolver);
    if ("rawQueryPipeline" in $$props2)
      $$invalidate(10, rawQueryPipeline = $$props2.rawQueryPipeline);
    if ("rawPhysicsPipeline" in $$props2)
      $$invalidate(11, rawPhysicsPipeline = $$props2.rawPhysicsPipeline);
    if ("rawSerializationPipeline" in $$props2)
      $$invalidate(12, rawSerializationPipeline = $$props2.rawSerializationPipeline);
    if ("rawDebugRenderPipeline" in $$props2)
      $$invalidate(13, rawDebugRenderPipeline = $$props2.rawDebugRenderPipeline);
    if ("order" in $$props2)
      $$invalidate(14, order = $$props2.order);
    if ("error" in $$props2)
      $$invalidate(15, error = $$props2.error);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    gravity,
    rawIntegrationParameters,
    rawIslands,
    rawBroadPhase,
    rawNarrowPhase,
    rawBodies,
    rawColliders,
    rawImpulseJoints,
    rawMultibodyJoints,
    rawCCDSolver,
    rawQueryPipeline,
    rawPhysicsPipeline,
    rawSerializationPipeline,
    rawDebugRenderPipeline,
    order,
    error,
    $initialized,
    slots,
    $$scope
  ];
}
var World = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      gravity: 0,
      rawIntegrationParameters: 1,
      rawIslands: 2,
      rawBroadPhase: 3,
      rawNarrowPhase: 4,
      rawBodies: 5,
      rawColliders: 6,
      rawImpulseJoints: 7,
      rawMultibodyJoints: 8,
      rawCCDSolver: 9,
      rawQueryPipeline: 10,
      rawPhysicsPipeline: 11,
      rawSerializationPipeline: 12,
      rawDebugRenderPipeline: 13,
      order: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "World",
      options,
      id: create_fragment2.name
    });
  }
  get gravity() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gravity(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawIntegrationParameters() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawIntegrationParameters(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawIslands() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawIslands(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawBroadPhase() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawBroadPhase(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawNarrowPhase() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawNarrowPhase(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawBodies() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawBodies(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawColliders() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawColliders(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawImpulseJoints() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawImpulseJoints(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawMultibodyJoints() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawMultibodyJoints(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawCCDSolver() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawCCDSolver(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawQueryPipeline() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawQueryPipeline(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawPhysicsPipeline() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawPhysicsPipeline(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawSerializationPipeline() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawSerializationPipeline(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rawDebugRenderPipeline() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rawDebugRenderPipeline(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get order() {
    throw new Error("<World>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set order(value) {
    throw new Error("<World>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var World_default = World;

// node_modules/@threlte/rapier/dist/hooks/useHasEventListener.js
var useHasEventListeners = () => {
  const component = get_current_component();
  const hasEventListeners = (type) => {
    const callbacks = component.$$.callbacks;
    return type in callbacks && callbacks[type].length > 0;
  };
  return {
    hasEventListeners
  };
};

// node_modules/@threlte/rapier/dist/lib/getWorldTransforms.js
var tempPosition = new Vector3();
var tempQuaternion2 = new Quaternion();
var tempRotation = new Euler();
var tempScale = new Vector3();
var getWorldPosition = (object, target) => {
  return object.getWorldPosition(target ?? tempPosition);
};
var getWorldQuaternion = (object, target) => {
  return object.getWorldQuaternion(target ?? tempQuaternion2);
};
var getWorldScale = (object, target) => {
  return object.getWorldScale(target ?? tempScale);
};

// node_modules/@threlte/rapier/dist/lib/parseRigidBodyType.js
var rigidBodyTypeMap = {
  dynamic: SA.Dynamic,
  fixed: SA.Fixed,
  kinematicPosition: SA.KinematicPositionBased,
  kinematicVelocity: SA.KinematicVelocityBased
};
var parseRigidBodyType = (type) => {
  return rigidBodyTypeMap[type];
};

// node_modules/@threlte/rapier/dist/components/RigidBody/RigidBody.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(107:0) <SceneGraphObject {object}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let scenegraphobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*object*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const scenegraphobject_changes = {};
      if (dirty & /*object*/
      1)
        scenegraphobject_changes.object = /*object*/
        ctx2[0];
      if (dirty & /*$$scope*/
      262144) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RigidBody", slots, ["default"]);
  const { world, rapier, addRigidBodyToContext, removeRigidBodyFromContext } = useRapier();
  let { linearVelocity = void 0 } = $$props;
  let { angularVelocity = void 0 } = $$props;
  let { type = "dynamic" } = $$props;
  let { canSleep = true } = $$props;
  let { gravityScale = 1 } = $$props;
  let { ccd = false } = $$props;
  let { angularDamping = 0 } = $$props;
  let { linearDamping = 0 } = $$props;
  let { lockRotations = false } = $$props;
  let { lockTranslations = false } = $$props;
  let { enabledRotations = [true, true, true] } = $$props;
  let { enabledTranslations = [true, true, true] } = $$props;
  let { dominance = 0 } = $$props;
  let { enabled = true } = $$props;
  const dispatcher = createRawEventDispatcher();
  const object = new Object3D();
  object.userData.isRigidBody = true;
  object.userData.isSleeping = false;
  const desc = new rapier.RigidBodyDesc(parseRigidBodyType(type)).setCanSleep(canSleep);
  let { rigidBody = void 0 } = $$props;
  const rigidBodyTemp = world.createRigidBody(desc);
  const initPosition = async () => {
    await tick();
    object.updateMatrix();
    object.updateWorldMatrix(true, false);
    const parentWorldScale = object.parent ? getWorldScale(object.parent) : new Vector3(1, 1, 1);
    const worldPosition = getWorldPosition(object).multiply(parentWorldScale);
    const worldQuaternion = getWorldQuaternion(object);
    rigidBodyTemp.setTranslation(worldPosition, true);
    rigidBodyTemp.setRotation(worldQuaternion, true);
    $$invalidate(1, rigidBody = rigidBodyTemp);
  };
  initPosition();
  object.userData.rigidBody = rigidBodyTemp;
  const { hasEventListeners } = useHasEventListeners();
  rigidBodyTemp.userData = { hasEventListeners };
  setContext("threlte-rapier-rigidbody", rigidBodyTemp);
  addRigidBodyToContext(rigidBodyTemp, object, dispatcher);
  onDestroy(() => {
    removeRigidBodyFromContext(rigidBodyTemp);
    world.removeRigidBody(rigidBodyTemp);
  });
  const writable_props = [
    "linearVelocity",
    "angularVelocity",
    "type",
    "canSleep",
    "gravityScale",
    "ccd",
    "angularDamping",
    "linearDamping",
    "lockRotations",
    "lockTranslations",
    "enabledRotations",
    "enabledTranslations",
    "dominance",
    "enabled",
    "rigidBody"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RigidBody> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("linearVelocity" in $$props2)
      $$invalidate(2, linearVelocity = $$props2.linearVelocity);
    if ("angularVelocity" in $$props2)
      $$invalidate(3, angularVelocity = $$props2.angularVelocity);
    if ("type" in $$props2)
      $$invalidate(4, type = $$props2.type);
    if ("canSleep" in $$props2)
      $$invalidate(5, canSleep = $$props2.canSleep);
    if ("gravityScale" in $$props2)
      $$invalidate(6, gravityScale = $$props2.gravityScale);
    if ("ccd" in $$props2)
      $$invalidate(7, ccd = $$props2.ccd);
    if ("angularDamping" in $$props2)
      $$invalidate(8, angularDamping = $$props2.angularDamping);
    if ("linearDamping" in $$props2)
      $$invalidate(9, linearDamping = $$props2.linearDamping);
    if ("lockRotations" in $$props2)
      $$invalidate(10, lockRotations = $$props2.lockRotations);
    if ("lockTranslations" in $$props2)
      $$invalidate(11, lockTranslations = $$props2.lockTranslations);
    if ("enabledRotations" in $$props2)
      $$invalidate(12, enabledRotations = $$props2.enabledRotations);
    if ("enabledTranslations" in $$props2)
      $$invalidate(13, enabledTranslations = $$props2.enabledTranslations);
    if ("dominance" in $$props2)
      $$invalidate(14, dominance = $$props2.dominance);
    if ("enabled" in $$props2)
      $$invalidate(15, enabled = $$props2.enabled);
    if ("rigidBody" in $$props2)
      $$invalidate(1, rigidBody = $$props2.rigidBody);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createRawEventDispatcher,
    SceneGraphObject: SceneGraphObject_default,
    onDestroy,
    setContext,
    tick,
    Object3D,
    Vector3,
    useHasEventListeners,
    useRapier,
    getWorldPosition,
    getWorldQuaternion,
    getWorldScale,
    parseRigidBodyType,
    world,
    rapier,
    addRigidBodyToContext,
    removeRigidBodyFromContext,
    linearVelocity,
    angularVelocity,
    type,
    canSleep,
    gravityScale,
    ccd,
    angularDamping,
    linearDamping,
    lockRotations,
    lockTranslations,
    enabledRotations,
    enabledTranslations,
    dominance,
    enabled,
    dispatcher,
    object,
    desc,
    rigidBody,
    rigidBodyTemp,
    initPosition,
    hasEventListeners
  });
  $$self.$inject_state = ($$props2) => {
    if ("linearVelocity" in $$props2)
      $$invalidate(2, linearVelocity = $$props2.linearVelocity);
    if ("angularVelocity" in $$props2)
      $$invalidate(3, angularVelocity = $$props2.angularVelocity);
    if ("type" in $$props2)
      $$invalidate(4, type = $$props2.type);
    if ("canSleep" in $$props2)
      $$invalidate(5, canSleep = $$props2.canSleep);
    if ("gravityScale" in $$props2)
      $$invalidate(6, gravityScale = $$props2.gravityScale);
    if ("ccd" in $$props2)
      $$invalidate(7, ccd = $$props2.ccd);
    if ("angularDamping" in $$props2)
      $$invalidate(8, angularDamping = $$props2.angularDamping);
    if ("linearDamping" in $$props2)
      $$invalidate(9, linearDamping = $$props2.linearDamping);
    if ("lockRotations" in $$props2)
      $$invalidate(10, lockRotations = $$props2.lockRotations);
    if ("lockTranslations" in $$props2)
      $$invalidate(11, lockTranslations = $$props2.lockTranslations);
    if ("enabledRotations" in $$props2)
      $$invalidate(12, enabledRotations = $$props2.enabledRotations);
    if ("enabledTranslations" in $$props2)
      $$invalidate(13, enabledTranslations = $$props2.enabledTranslations);
    if ("dominance" in $$props2)
      $$invalidate(14, dominance = $$props2.dominance);
    if ("enabled" in $$props2)
      $$invalidate(15, enabled = $$props2.enabled);
    if ("rigidBody" in $$props2)
      $$invalidate(1, rigidBody = $$props2.rigidBody);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*rigidBodyTemp, type*/
    65552) {
      $:
        rigidBodyTemp.setBodyType(parseRigidBodyType(type), true);
    }
    if ($$self.$$.dirty & /*linearVelocity, rigidBodyTemp*/
    65540) {
      $:
        if (linearVelocity)
          rigidBodyTemp.setLinvel(
            {
              x: linearVelocity[0],
              y: linearVelocity[1],
              z: linearVelocity[2]
            },
            true
          );
    }
    if ($$self.$$.dirty & /*angularVelocity, rigidBodyTemp*/
    65544) {
      $:
        if (angularVelocity)
          rigidBodyTemp.setAngvel(
            {
              x: angularVelocity[0],
              y: angularVelocity[1],
              z: angularVelocity[2]
            },
            true
          );
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, gravityScale*/
    65600) {
      $:
        rigidBodyTemp.setGravityScale(gravityScale, true);
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, ccd*/
    65664) {
      $:
        rigidBodyTemp.enableCcd(ccd);
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, dominance*/
    81920) {
      $:
        rigidBodyTemp.setDominanceGroup(dominance);
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, lockRotations*/
    66560) {
      $:
        rigidBodyTemp.lockRotations(lockRotations, true);
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, lockTranslations*/
    67584) {
      $:
        rigidBodyTemp.lockTranslations(lockTranslations, true);
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, enabledRotations*/
    69632) {
      $:
        rigidBodyTemp.setEnabledRotations(...enabledRotations, true);
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, enabledTranslations*/
    73728) {
      $:
        rigidBodyTemp.setEnabledTranslations(...enabledTranslations, true);
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, angularDamping*/
    65792) {
      $:
        rigidBodyTemp.setAngularDamping(angularDamping);
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, linearDamping*/
    66048) {
      $:
        rigidBodyTemp.setLinearDamping(linearDamping);
    }
    if ($$self.$$.dirty & /*rigidBodyTemp, enabled*/
    98304) {
      $:
        rigidBodyTemp.setEnabled(enabled);
    }
  };
  return [
    object,
    rigidBody,
    linearVelocity,
    angularVelocity,
    type,
    canSleep,
    gravityScale,
    ccd,
    angularDamping,
    linearDamping,
    lockRotations,
    lockTranslations,
    enabledRotations,
    enabledTranslations,
    dominance,
    enabled,
    rigidBodyTemp,
    slots,
    $$scope
  ];
}
var RigidBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      linearVelocity: 2,
      angularVelocity: 3,
      type: 4,
      canSleep: 5,
      gravityScale: 6,
      ccd: 7,
      angularDamping: 8,
      linearDamping: 9,
      lockRotations: 10,
      lockTranslations: 11,
      enabledRotations: 12,
      enabledTranslations: 13,
      dominance: 14,
      enabled: 15,
      rigidBody: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RigidBody",
      options,
      id: create_fragment3.name
    });
  }
  get linearVelocity() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linearVelocity(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angularVelocity() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angularVelocity(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canSleep() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canSleep(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gravityScale() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gravityScale(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ccd() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ccd(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angularDamping() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angularDamping(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linearDamping() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linearDamping(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lockRotations() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lockRotations(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lockTranslations() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lockTranslations(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enabledRotations() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabledRotations(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enabledTranslations() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabledTranslations(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dominance() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dominance(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enabled() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabled(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rigidBody() {
    throw new Error("<RigidBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rigidBody(value) {
    throw new Error("<RigidBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RigidBody_default = RigidBody;

// node_modules/@threlte/rapier/dist/components/Debug/Debug.svelte
function create_default_slot3(ctx) {
  let t0;
  let t1;
  let t_linebasicmaterial;
  let current;
  t0 = new T({
    props: {
      is: (
        /*geometry*/
        ctx[0]
      ),
      attach: "geometry"
    },
    $$inline: true
  });
  const t_linebasicmaterial_spread_levels = [
    { vertexColors: true },
    /*$$restProps*/
    ctx[1]
  ];
  let t_linebasicmaterial_props = {};
  for (let i = 0; i < t_linebasicmaterial_spread_levels.length; i += 1) {
    t_linebasicmaterial_props = assign(t_linebasicmaterial_props, t_linebasicmaterial_spread_levels[i]);
  }
  t_linebasicmaterial = new T.LineBasicMaterial({
    props: t_linebasicmaterial_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t0.$$.fragment);
      t1 = space();
      create_component(t_linebasicmaterial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(t_linebasicmaterial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(t_linebasicmaterial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_linebasicmaterial_changes = dirty & /*$$restProps*/
      2 ? get_spread_update(t_linebasicmaterial_spread_levels, [
        t_linebasicmaterial_spread_levels[0],
        get_spread_object(
          /*$$restProps*/
          ctx2[1]
        )
      ]) : {};
      t_linebasicmaterial.$set(t_linebasicmaterial_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t0.$$.fragment, local);
      transition_in(t_linebasicmaterial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t0.$$.fragment, local);
      transition_out(t_linebasicmaterial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t0, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(t_linebasicmaterial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(26:0) <T.LineSegments renderOrder={Infinity}>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let t_linesegments;
  let current;
  t_linesegments = new T.LineSegments({
    props: {
      renderOrder: Infinity,
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_linesegments.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_linesegments.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_linesegments, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_linesegments_changes = {};
      if (dirty & /*$$scope, $$restProps*/
      130) {
        t_linesegments_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_linesegments.$set(t_linesegments_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_linesegments.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_linesegments.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_linesegments, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Debug", slots, []);
  const { world, debug } = useRapier();
  const buffers = world.debugRender();
  const vertices = new BufferAttribute(buffers.vertices, 3);
  const colors = new BufferAttribute(buffers.colors, 4);
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", vertices);
  geometry.setAttribute("color", colors);
  debug.set(true);
  useFrame(() => {
    const buffers2 = world.debugRender();
    const vertices2 = new BufferAttribute(buffers2.vertices, 3);
    const colors2 = new BufferAttribute(buffers2.colors, 4);
    geometry.setAttribute("position", vertices2);
    geometry.setAttribute("color", colors2);
  });
  onDestroy(() => {
    geometry.dispose();
    debug.set(false);
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$capture_state = () => ({
    T,
    useFrame,
    onDestroy,
    BufferAttribute,
    BufferGeometry,
    useRapier,
    world,
    debug,
    buffers,
    vertices,
    colors,
    geometry
  });
  return [geometry, $$restProps];
}
var Debug = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Debug",
      options,
      id: create_fragment4.name
    });
  }
};
var Debug_default = Debug;

// node_modules/@threlte/rapier/dist/lib/applyColliderActiveEvents.js
var applyColliderActiveEvents = (collider, colliderHasEventListeners, rigidBodyHasEventListeners) => {
  let events = 0;
  if (colliderHasEventListeners("collisionenter") || colliderHasEventListeners("collisionexit") || (rigidBodyHasEventListeners == null ? void 0 : rigidBodyHasEventListeners("collisionenter")) || (rigidBodyHasEventListeners == null ? void 0 : rigidBodyHasEventListeners("collisionexit")) || colliderHasEventListeners("sensorenter") || colliderHasEventListeners("sensorexit") || (rigidBodyHasEventListeners == null ? void 0 : rigidBodyHasEventListeners("sensorenter")) || (rigidBodyHasEventListeners == null ? void 0 : rigidBodyHasEventListeners("sensorexit"))) {
    events = events | FA.COLLISION_EVENTS;
  }
  if (colliderHasEventListeners("contact") || (rigidBodyHasEventListeners == null ? void 0 : rigidBodyHasEventListeners("contact"))) {
    events = events | FA.CONTACT_FORCE_EVENTS;
  }
  if (events > 0) {
    collider.setActiveEvents(events);
  }
};

// node_modules/@threlte/rapier/dist/lib/eulerToQuaternion.js
var e = new Euler();
var q = new Quaternion();
var eulerToQuaternion = (values) => {
  e.set(...values);
  return q.setFromEuler(e);
};

// node_modules/@threlte/rapier/dist/lib/scaleColliderArgs.js
var scaleVertices = (vertices, scale) => {
  const scaledVerts = Array.from(vertices);
  for (let i = 0; i < vertices.length / 3; i++) {
    scaledVerts[i * 3] *= scale.x;
    scaledVerts[i * 3 + 1] *= scale.y;
    scaledVerts[i * 3 + 2] *= scale.z;
  }
  return scaledVerts;
};
var scaleColliderArgs = (shape, args, scale) => {
  const newArgs = args.slice();
  if (shape === "heightfield") {
    return newArgs;
  }
  if (shape === "trimesh" || shape === "convexHull") {
    newArgs[0] = new Float32Array(scaleVertices(newArgs[0], scale));
    return newArgs;
  }
  const scaleArray = [scale.x, scale.y, scale.z];
  return newArgs.map((arg, index) => (scaleArray[index] ?? 1) * arg);
};

// node_modules/@threlte/rapier/dist/components/Colliders/Collider.svelte
var get_default_slot_changes = (dirty) => ({ collider: dirty & /*collider*/
1 });
var get_default_slot_context = (ctx) => ({ collider: (
  /*collider*/
  ctx[0]
) });
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, collider*/
        262145)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(138:0) <SceneGraphObject {object}>",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let scenegraphobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*object*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const scenegraphobject_changes = {};
      if (dirty & /*$$scope, collider*/
      262145) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Collider", slots, ["default"]);
  let { shape } = $$props;
  let { args } = $$props;
  let { type = void 0 } = $$props;
  let { restitution = void 0 } = $$props;
  let { restitutionCombineRule = void 0 } = $$props;
  let { friction = void 0 } = $$props;
  let { frictionCombineRule = void 0 } = $$props;
  let { sensor = void 0 } = $$props;
  let { contactForceEventThreshold = void 0 } = $$props;
  let { density = void 0 } = $$props;
  let { mass = void 0 } = $$props;
  let { centerOfMass = void 0 } = $$props;
  let { principalAngularInertia = void 0 } = $$props;
  let { angularInertiaLocalFrame = void 0 } = $$props;
  const object = new Object3D();
  const rigidBody = useRigidBody();
  const hasRigidBodyParent = !!rigidBody;
  const rapierContext = useRapier();
  const { world } = rapierContext;
  let { collider = void 0 } = $$props;
  const collisionGroups = useCollisionGroups();
  const dispatcher = createRawEventDispatcher();
  onMount(async () => {
    await tick();
    const scale = object.getWorldScale(new Vector3());
    const scaledArgs = scaleColliderArgs(shape, args, scale);
    const colliderDesc = RI[shape](...scaledArgs);
    $$invalidate(0, collider = world.createCollider(colliderDesc, rigidBody));
    rapierContext.addColliderToContext(collider, object, dispatcher);
    collisionGroups.registerColliders([collider]);
    if (hasRigidBodyParent) {
      const rigidBodyWorldPos = new Vector3();
      const rigidBodyWorldQuatInversed = new Quaternion();
      object.traverseAncestors((child) => {
        if (child.userData.isRigidBody) {
          child.getWorldPosition(rigidBodyWorldPos);
          child.getWorldQuaternion(rigidBodyWorldQuatInversed);
          rigidBodyWorldQuatInversed.invert();
        }
      });
      const worldPosition = object.getWorldPosition(new Vector3()).sub(rigidBodyWorldPos);
      const worldRotation = object.getWorldQuaternion(new Quaternion()).premultiply(rigidBodyWorldQuatInversed);
      collider.setTranslationWrtParent(worldPosition);
      collider.setRotationWrtParent(worldRotation);
    } else {
      collider.setTranslation(object.getWorldPosition(new Vector3()));
      collider.setRotation(object.getWorldQuaternion(new Quaternion()));
    }
  });
  const { hasEventListeners: colliderHasEventListeners } = useHasEventListeners();
  const refresh = () => {
    if (!collider)
      return;
    collider.setTranslation(getWorldPosition(object));
    collider.setRotation(getWorldQuaternion(object));
  };
  const { start, stop } = useFrame(
    () => {
      refresh();
    },
    {
      autostart: !hasRigidBodyParent && type === "dynamic"
    }
  );
  onDestroy(() => {
    if (!collider)
      return;
    rapierContext.removeColliderFromContext(collider);
    collisionGroups.removeColliders([collider]);
    world.removeCollider(collider, true);
    $$invalidate(0, collider = void 0);
  });
  $$self.$$.on_mount.push(function() {
    if (shape === void 0 && !("shape" in $$props || $$self.$$.bound[$$self.$$.props["shape"]])) {
      console.warn("<Collider> was created without expected prop 'shape'");
    }
    if (args === void 0 && !("args" in $$props || $$self.$$.bound[$$self.$$.props["args"]])) {
      console.warn("<Collider> was created without expected prop 'args'");
    }
  });
  const writable_props = [
    "shape",
    "args",
    "type",
    "restitution",
    "restitutionCombineRule",
    "friction",
    "frictionCombineRule",
    "sensor",
    "contactForceEventThreshold",
    "density",
    "mass",
    "centerOfMass",
    "principalAngularInertia",
    "angularInertiaLocalFrame",
    "collider"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Collider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("shape" in $$props2)
      $$invalidate(2, shape = $$props2.shape);
    if ("args" in $$props2)
      $$invalidate(3, args = $$props2.args);
    if ("type" in $$props2)
      $$invalidate(4, type = $$props2.type);
    if ("restitution" in $$props2)
      $$invalidate(5, restitution = $$props2.restitution);
    if ("restitutionCombineRule" in $$props2)
      $$invalidate(6, restitutionCombineRule = $$props2.restitutionCombineRule);
    if ("friction" in $$props2)
      $$invalidate(7, friction = $$props2.friction);
    if ("frictionCombineRule" in $$props2)
      $$invalidate(8, frictionCombineRule = $$props2.frictionCombineRule);
    if ("sensor" in $$props2)
      $$invalidate(9, sensor = $$props2.sensor);
    if ("contactForceEventThreshold" in $$props2)
      $$invalidate(10, contactForceEventThreshold = $$props2.contactForceEventThreshold);
    if ("density" in $$props2)
      $$invalidate(11, density = $$props2.density);
    if ("mass" in $$props2)
      $$invalidate(12, mass = $$props2.mass);
    if ("centerOfMass" in $$props2)
      $$invalidate(13, centerOfMass = $$props2.centerOfMass);
    if ("principalAngularInertia" in $$props2)
      $$invalidate(14, principalAngularInertia = $$props2.principalAngularInertia);
    if ("angularInertiaLocalFrame" in $$props2)
      $$invalidate(15, angularInertiaLocalFrame = $$props2.angularInertiaLocalFrame);
    if ("collider" in $$props2)
      $$invalidate(0, collider = $$props2.collider);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ActiveCollisionTypes: UA,
    CoefficientCombineRule: KA,
    Collider: qI,
    ColliderDesc: RI,
    createRawEventDispatcher,
    SceneGraphObject: SceneGraphObject_default,
    useFrame,
    onDestroy,
    onMount,
    tick,
    Object3D,
    Quaternion,
    Vector3,
    useCollisionGroups,
    useHasEventListeners,
    useRapier,
    useRigidBody,
    applyColliderActiveEvents,
    eulerToQuaternion,
    getWorldPosition,
    getWorldQuaternion,
    scaleColliderArgs,
    shape,
    args,
    type,
    restitution,
    restitutionCombineRule,
    friction,
    frictionCombineRule,
    sensor,
    contactForceEventThreshold,
    density,
    mass,
    centerOfMass,
    principalAngularInertia,
    angularInertiaLocalFrame,
    object,
    rigidBody,
    hasRigidBodyParent,
    rapierContext,
    world,
    collider,
    collisionGroups,
    dispatcher,
    colliderHasEventListeners,
    refresh,
    start,
    stop
  });
  $$self.$inject_state = ($$props2) => {
    if ("shape" in $$props2)
      $$invalidate(2, shape = $$props2.shape);
    if ("args" in $$props2)
      $$invalidate(3, args = $$props2.args);
    if ("type" in $$props2)
      $$invalidate(4, type = $$props2.type);
    if ("restitution" in $$props2)
      $$invalidate(5, restitution = $$props2.restitution);
    if ("restitutionCombineRule" in $$props2)
      $$invalidate(6, restitutionCombineRule = $$props2.restitutionCombineRule);
    if ("friction" in $$props2)
      $$invalidate(7, friction = $$props2.friction);
    if ("frictionCombineRule" in $$props2)
      $$invalidate(8, frictionCombineRule = $$props2.frictionCombineRule);
    if ("sensor" in $$props2)
      $$invalidate(9, sensor = $$props2.sensor);
    if ("contactForceEventThreshold" in $$props2)
      $$invalidate(10, contactForceEventThreshold = $$props2.contactForceEventThreshold);
    if ("density" in $$props2)
      $$invalidate(11, density = $$props2.density);
    if ("mass" in $$props2)
      $$invalidate(12, mass = $$props2.mass);
    if ("centerOfMass" in $$props2)
      $$invalidate(13, centerOfMass = $$props2.centerOfMass);
    if ("principalAngularInertia" in $$props2)
      $$invalidate(14, principalAngularInertia = $$props2.principalAngularInertia);
    if ("angularInertiaLocalFrame" in $$props2)
      $$invalidate(15, angularInertiaLocalFrame = $$props2.angularInertiaLocalFrame);
    if ("collider" in $$props2)
      $$invalidate(0, collider = $$props2.collider);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*collider, restitution, restitutionCombineRule, friction, frictionCombineRule, sensor, contactForceEventThreshold, density, mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame*/
    65505) {
      $: {
        if (collider) {
          applyColliderActiveEvents(collider, colliderHasEventListeners, (_a = rigidBody == null ? void 0 : rigidBody.userData) == null ? void 0 : _a.hasEventListeners);
          collider.setActiveCollisionTypes(UA.ALL);
          collider.setRestitution(restitution ?? 0);
          collider.setContactForceEventThreshold(1);
          collider.setRestitutionCombineRule(restitutionCombineRule ?? KA.Average);
          collider.setFriction(friction ?? 0.7);
          collider.setFrictionCombineRule(frictionCombineRule ?? KA.Average);
          collider.setSensor(sensor ?? false);
          collider.setContactForceEventThreshold(contactForceEventThreshold ?? 0);
          if (density)
            collider.setDensity(density);
          if (mass) {
            if (centerOfMass && principalAngularInertia && angularInertiaLocalFrame) {
              collider.setMassProperties(
                mass,
                {
                  x: centerOfMass[0],
                  y: centerOfMass[1],
                  z: centerOfMass[2]
                },
                {
                  x: principalAngularInertia[0],
                  y: principalAngularInertia[1],
                  z: principalAngularInertia[2]
                },
                eulerToQuaternion(angularInertiaLocalFrame)
              );
            } else {
              collider.setMass(mass);
            }
          }
        }
      }
    }
    if ($$self.$$.dirty & /*type*/
    16) {
      $: {
        if (!hasRigidBodyParent && type === "dynamic")
          start();
        else
          stop();
      }
    }
  };
  return [
    collider,
    object,
    shape,
    args,
    type,
    restitution,
    restitutionCombineRule,
    friction,
    frictionCombineRule,
    sensor,
    contactForceEventThreshold,
    density,
    mass,
    centerOfMass,
    principalAngularInertia,
    angularInertiaLocalFrame,
    refresh,
    slots,
    $$scope
  ];
}
var Collider_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      shape: 2,
      args: 3,
      type: 4,
      restitution: 5,
      restitutionCombineRule: 6,
      friction: 7,
      frictionCombineRule: 8,
      sensor: 9,
      contactForceEventThreshold: 10,
      density: 11,
      mass: 12,
      centerOfMass: 13,
      principalAngularInertia: 14,
      angularInertiaLocalFrame: 15,
      collider: 0,
      refresh: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Collider_1",
      options,
      id: create_fragment5.name
    });
  }
  get shape() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shape(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get args() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set args(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get restitution() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set restitution(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get restitutionCombineRule() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set restitutionCombineRule(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get friction() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set friction(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frictionCombineRule() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frictionCombineRule(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sensor() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sensor(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contactForceEventThreshold() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contactForceEventThreshold(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get density() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set density(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mass() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mass(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get centerOfMass() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set centerOfMass(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get principalAngularInertia() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set principalAngularInertia(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angularInertiaLocalFrame() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angularInertiaLocalFrame(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collider() {
    throw new Error("<Collider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collider(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refresh() {
    return this.$$.ctx[16];
  }
  set refresh(value) {
    throw new Error("<Collider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Collider_default = Collider_1;

// node_modules/@threlte/rapier/dist/lib/createCollidersFromChildren.js
var createCollidersFromChildren = (object, collidersType, world, rigidBody) => {
  const colliders = [];
  let description;
  const offset = new Vector3();
  const rigidBodyWorldPos = new Vector3();
  const rigidBodyWorldQuatInversed = new Quaternion();
  object.traverseAncestors((child) => {
    if (child.userData.isRigidBody) {
      child.getWorldPosition(rigidBodyWorldPos);
      child.getWorldQuaternion(rigidBodyWorldQuatInversed);
      rigidBodyWorldQuatInversed.invert();
    }
  });
  object.traverse((child) => {
    var _a;
    if ("isMesh" in child) {
      const { geometry } = child;
      const worldPos = child.getWorldPosition(new Vector3());
      const { x, y, z } = worldPos.sub(rigidBodyWorldPos);
      const worldQuat = child.getWorldQuaternion(new Quaternion());
      const { x: rx, y: ry, z: rz, w: rw } = worldQuat.clone().premultiply(rigidBodyWorldQuatInversed);
      const scale = child.getWorldScale(new Vector3());
      switch (collidersType) {
        case "cuboid":
          {
            geometry.computeBoundingBox();
            const { boundingBox } = geometry;
            const size = boundingBox.getSize(new Vector3());
            boundingBox.getCenter(offset);
            description = RI.cuboid(size.x / 2 * scale.x, size.y / 2 * scale.y, size.z / 2 * scale.z);
          }
          break;
        case "ball":
          {
            geometry.computeBoundingSphere();
            const { boundingSphere } = geometry;
            const radius = boundingSphere.radius * scale.x;
            offset.copy(boundingSphere.center);
            description = RI.ball(radius);
          }
          break;
        case "trimesh":
          {
            const g2 = geometry.clone().scale(scale.x, scale.y, scale.z);
            description = RI.trimesh(g2.attributes.position.array, (_a = g2.index) == null ? void 0 : _a.array);
          }
          break;
        case "capsule":
          {
            geometry.computeBoundingBox();
            const { boundingBox } = geometry;
            const size = boundingBox.getSize(new Vector3());
            boundingBox.getCenter(offset);
            const radius = Math.max(size.x / 2 * scale.x, size.z / 2 * scale.z);
            description = RI.capsule(size.y / 2 * scale.y - radius, radius);
          }
          break;
        case "convexHull":
          const g = geometry.clone().scale(scale.x, scale.y, scale.z);
          {
            description = RI.convexHull(g.attributes.position.array);
          }
          break;
      }
      description.setTranslation(x + offset.x, y + offset.y, z + offset.z).setRotation({ x: rx, y: ry, z: rz, w: rw }).setActiveEvents(FA.COLLISION_EVENTS);
      const collider = world.createCollider(description, rigidBody);
      colliders.push(collider);
    }
  });
  return colliders;
};

// node_modules/@threlte/rapier/dist/components/Colliders/AutoColliders.svelte
var get_default_slot_changes2 = (dirty) => ({ colliders: dirty & /*colliders*/
1 });
var get_default_slot_context2 = (ctx) => ({
  colliders: (
    /*colliders*/
    ctx[0]
  ),
  refresh: (
    /*refresh*/
    ctx[1]
  )
});
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, colliders*/
        131073)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(79:0) <SceneGraphObject object={group}>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let scenegraphobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*group*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scenegraphobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const scenegraphobject_changes = {};
      if (dirty & /*$$scope, colliders*/
      131073) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scenegraphobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AutoColliders", slots, ["default"]);
  let { shape = "convexHull" } = $$props;
  let { restitution = void 0 } = $$props;
  let { restitutionCombineRule = void 0 } = $$props;
  let { friction = void 0 } = $$props;
  let { frictionCombineRule = void 0 } = $$props;
  let { sensor = void 0 } = $$props;
  let { contactForceEventThreshold = void 0 } = $$props;
  let { density = void 0 } = $$props;
  let { mass = void 0 } = $$props;
  let { centerOfMass = void 0 } = $$props;
  let { principalAngularInertia = void 0 } = $$props;
  let { angularInertiaLocalFrame = void 0 } = $$props;
  const group = new Group();
  const rigidBody = useRigidBody();
  const { world, addColliderToContext, removeColliderFromContext } = useRapier();
  let { colliders = [] } = $$props;
  const collisionGroups = useCollisionGroups();
  const dispatcher = createRawEventDispatcher();
  const { hasEventListeners: colliderHasEventListeners } = useHasEventListeners();
  const cleanup = () => {
    collisionGroups.removeColliders(colliders);
    colliders.forEach((c) => {
      removeColliderFromContext(c);
      world.removeCollider(c, true);
    });
    $$invalidate(0, colliders.length = 0, colliders);
  };
  const create = () => {
    cleanup();
    $$invalidate(0, colliders = createCollidersFromChildren(group, shape ?? "convexHull", world, rigidBody));
    colliders.forEach((c) => addColliderToContext(c, group, dispatcher));
    collisionGroups.registerColliders(colliders);
    colliders.forEach((collider) => {
      var _a;
      applyColliderActiveEvents(collider, colliderHasEventListeners, (_a = rigidBody == null ? void 0 : rigidBody.userData) == null ? void 0 : _a.hasEventListeners);
      collider.setActiveCollisionTypes(UA.ALL);
      collider.setRestitution(restitution ?? 0);
      collider.setRestitutionCombineRule(restitutionCombineRule ?? KA.Average);
      collider.setFriction(friction ?? 0.7);
      collider.setFrictionCombineRule(frictionCombineRule ?? KA.Average);
      collider.setSensor(sensor ?? false);
      collider.setContactForceEventThreshold(contactForceEventThreshold ?? 0);
      if (density)
        collider.setDensity(density);
      if (mass) {
        if (centerOfMass && principalAngularInertia && angularInertiaLocalFrame)
          collider.setMassProperties(
            mass,
            {
              x: centerOfMass[0],
              y: centerOfMass[1],
              z: centerOfMass[2]
            },
            {
              x: principalAngularInertia[0],
              y: principalAngularInertia[1],
              z: principalAngularInertia[2]
            },
            eulerToQuaternion(angularInertiaLocalFrame)
          );
        else
          collider.setMass(mass);
      }
    });
  };
  onMount(() => {
    create();
  });
  const refresh = () => {
    create();
  };
  onDestroy(cleanup);
  const writable_props = [
    "shape",
    "restitution",
    "restitutionCombineRule",
    "friction",
    "frictionCombineRule",
    "sensor",
    "contactForceEventThreshold",
    "density",
    "mass",
    "centerOfMass",
    "principalAngularInertia",
    "angularInertiaLocalFrame",
    "colliders"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AutoColliders> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("shape" in $$props2)
      $$invalidate(3, shape = $$props2.shape);
    if ("restitution" in $$props2)
      $$invalidate(4, restitution = $$props2.restitution);
    if ("restitutionCombineRule" in $$props2)
      $$invalidate(5, restitutionCombineRule = $$props2.restitutionCombineRule);
    if ("friction" in $$props2)
      $$invalidate(6, friction = $$props2.friction);
    if ("frictionCombineRule" in $$props2)
      $$invalidate(7, frictionCombineRule = $$props2.frictionCombineRule);
    if ("sensor" in $$props2)
      $$invalidate(8, sensor = $$props2.sensor);
    if ("contactForceEventThreshold" in $$props2)
      $$invalidate(9, contactForceEventThreshold = $$props2.contactForceEventThreshold);
    if ("density" in $$props2)
      $$invalidate(10, density = $$props2.density);
    if ("mass" in $$props2)
      $$invalidate(11, mass = $$props2.mass);
    if ("centerOfMass" in $$props2)
      $$invalidate(12, centerOfMass = $$props2.centerOfMass);
    if ("principalAngularInertia" in $$props2)
      $$invalidate(13, principalAngularInertia = $$props2.principalAngularInertia);
    if ("angularInertiaLocalFrame" in $$props2)
      $$invalidate(14, angularInertiaLocalFrame = $$props2.angularInertiaLocalFrame);
    if ("colliders" in $$props2)
      $$invalidate(0, colliders = $$props2.colliders);
    if ("$$scope" in $$props2)
      $$invalidate(17, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ActiveCollisionTypes: UA,
    CoefficientCombineRule: KA,
    createRawEventDispatcher,
    SceneGraphObject: SceneGraphObject_default,
    onDestroy,
    onMount,
    Group,
    useCollisionGroups,
    useHasEventListeners,
    useRapier,
    useRigidBody,
    applyColliderActiveEvents,
    createCollidersFromChildren,
    eulerToQuaternion,
    shape,
    restitution,
    restitutionCombineRule,
    friction,
    frictionCombineRule,
    sensor,
    contactForceEventThreshold,
    density,
    mass,
    centerOfMass,
    principalAngularInertia,
    angularInertiaLocalFrame,
    group,
    rigidBody,
    world,
    addColliderToContext,
    removeColliderFromContext,
    colliders,
    collisionGroups,
    dispatcher,
    colliderHasEventListeners,
    cleanup,
    create,
    refresh
  });
  $$self.$inject_state = ($$props2) => {
    if ("shape" in $$props2)
      $$invalidate(3, shape = $$props2.shape);
    if ("restitution" in $$props2)
      $$invalidate(4, restitution = $$props2.restitution);
    if ("restitutionCombineRule" in $$props2)
      $$invalidate(5, restitutionCombineRule = $$props2.restitutionCombineRule);
    if ("friction" in $$props2)
      $$invalidate(6, friction = $$props2.friction);
    if ("frictionCombineRule" in $$props2)
      $$invalidate(7, frictionCombineRule = $$props2.frictionCombineRule);
    if ("sensor" in $$props2)
      $$invalidate(8, sensor = $$props2.sensor);
    if ("contactForceEventThreshold" in $$props2)
      $$invalidate(9, contactForceEventThreshold = $$props2.contactForceEventThreshold);
    if ("density" in $$props2)
      $$invalidate(10, density = $$props2.density);
    if ("mass" in $$props2)
      $$invalidate(11, mass = $$props2.mass);
    if ("centerOfMass" in $$props2)
      $$invalidate(12, centerOfMass = $$props2.centerOfMass);
    if ("principalAngularInertia" in $$props2)
      $$invalidate(13, principalAngularInertia = $$props2.principalAngularInertia);
    if ("angularInertiaLocalFrame" in $$props2)
      $$invalidate(14, angularInertiaLocalFrame = $$props2.angularInertiaLocalFrame);
    if ("colliders" in $$props2)
      $$invalidate(0, colliders = $$props2.colliders);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    colliders,
    refresh,
    group,
    shape,
    restitution,
    restitutionCombineRule,
    friction,
    frictionCombineRule,
    sensor,
    contactForceEventThreshold,
    density,
    mass,
    centerOfMass,
    principalAngularInertia,
    angularInertiaLocalFrame,
    create,
    slots,
    $$scope
  ];
}
var AutoColliders = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      shape: 3,
      restitution: 4,
      restitutionCombineRule: 5,
      friction: 6,
      frictionCombineRule: 7,
      sensor: 8,
      contactForceEventThreshold: 9,
      density: 10,
      mass: 11,
      centerOfMass: 12,
      principalAngularInertia: 13,
      angularInertiaLocalFrame: 14,
      colliders: 0,
      create: 15,
      refresh: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AutoColliders",
      options,
      id: create_fragment6.name
    });
  }
  get shape() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shape(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get restitution() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set restitution(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get restitutionCombineRule() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set restitutionCombineRule(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get friction() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set friction(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frictionCombineRule() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frictionCombineRule(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sensor() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sensor(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contactForceEventThreshold() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contactForceEventThreshold(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get density() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set density(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mass() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mass(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get centerOfMass() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set centerOfMass(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get principalAngularInertia() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set principalAngularInertia(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angularInertiaLocalFrame() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angularInertiaLocalFrame(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colliders() {
    throw new Error("<AutoColliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colliders(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get create() {
    return this.$$.ctx[15];
  }
  set create(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refresh() {
    return this.$$.ctx[1];
  }
  set refresh(value) {
    throw new Error("<AutoColliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AutoColliders_default = AutoColliders;

// node_modules/@threlte/rapier/dist/lib/computeBitMask.js
var computeBitMask = (groups, filter, memberships) => {
  if (groups !== void 0) {
    const g = groups;
    const mask2 = g.reduce((acc, f) => {
      return acc | 1 << f;
    }, 0) | g.reduce((acc, m) => {
      return acc | 1 << m + 16;
    }, 0);
    return mask2;
  }
  const mask = memberships.reduce((acc, f) => {
    return acc | 1 << f;
  }, 0) | filter.reduce((acc, m) => {
    return acc | 1 << m + 16;
  }, 0);
  return mask;
};

// node_modules/@threlte/rapier/dist/components/CollisionGroups/CollisionGroups.svelte
function create_fragment7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CollisionGroups", slots, ["default"]);
  let { groups = void 0 } = $$props;
  let { filter = void 0 } = $$props;
  let { memberships = void 0 } = $$props;
  const store = writable(computeBitMask(groups, filter, memberships));
  setContext("threlte-rapier-collision-group", store);
  const writable_props = ["groups", "filter", "memberships"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CollisionGroups> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("groups" in $$props2)
      $$invalidate(0, groups = $$props2.groups);
    if ("filter" in $$props2)
      $$invalidate(1, filter = $$props2.filter);
    if ("memberships" in $$props2)
      $$invalidate(2, memberships = $$props2.memberships);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    writable,
    computeBitMask,
    groups,
    filter,
    memberships,
    store
  });
  $$self.$inject_state = ($$props2) => {
    if ("groups" in $$props2)
      $$invalidate(0, groups = $$props2.groups);
    if ("filter" in $$props2)
      $$invalidate(1, filter = $$props2.filter);
    if ("memberships" in $$props2)
      $$invalidate(2, memberships = $$props2.memberships);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*groups, filter, memberships*/
    7) {
      $:
        store.set(computeBitMask(groups, filter, memberships));
    }
  };
  return [groups, filter, memberships, $$scope, slots];
}
var CollisionGroups = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { groups: 0, filter: 1, memberships: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CollisionGroups",
      options,
      id: create_fragment7.name
    });
  }
  get groups() {
    throw new Error("<CollisionGroups>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groups(value) {
    throw new Error("<CollisionGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<CollisionGroups>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<CollisionGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get memberships() {
    throw new Error("<CollisionGroups>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set memberships(value) {
    throw new Error("<CollisionGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CollisionGroups_default = CollisionGroups;

// node_modules/@threlte/rapier/dist/components/Attractor/Attractor.svelte
var get_default_slot_changes3 = (dirty) => ({ ref: dirty & /*ref*/
16384 });
var get_default_slot_context3 = (ctx) => ({ ref: (
  /*ref*/
  ctx[14]
) });
function create_if_block2(ctx) {
  let t_mesh;
  let current;
  t_mesh = new T.Mesh({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_mesh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_mesh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_mesh, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_mesh_changes = {};
      if (dirty & /*$$scope, range*/
      513) {
        t_mesh_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_mesh.$set(t_mesh_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_mesh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_mesh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_mesh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(44:2) {#if $debug}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let t_spheregeometry;
  let t;
  let t_meshbasicmaterial;
  let current;
  t_spheregeometry = new T.SphereGeometry({
    props: { args: [
      /*range*/
      ctx[0]
    ] },
    $$inline: true
  });
  t_meshbasicmaterial = new T.MeshBasicMaterial({
    props: {
      wireframe: true,
      transparent: true,
      opacity: 0.25
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_spheregeometry.$$.fragment);
      t = space();
      create_component(t_meshbasicmaterial.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_spheregeometry.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(t_meshbasicmaterial.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_spheregeometry, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(t_meshbasicmaterial, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_spheregeometry_changes = {};
      if (dirty & /*range*/
      1)
        t_spheregeometry_changes.args = [
          /*range*/
          ctx2[0]
        ];
      t_spheregeometry.$set(t_spheregeometry_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_spheregeometry.$$.fragment, local);
      transition_in(t_meshbasicmaterial.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_spheregeometry.$$.fragment, local);
      transition_out(t_meshbasicmaterial.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_spheregeometry, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(t_meshbasicmaterial, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(45:4) <T.Mesh>",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let t;
  let if_block_anchor;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context3
  );
  let if_block = (
    /*$debug*/
    ctx[1] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        16896)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
      if (
        /*$debug*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$debug*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(37:0) <T   let:ref   is={obj}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let t;
  let current;
  const t_spread_levels = [
    { is: (
      /*obj*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let t_props = {
    $$slots: {
      default: [
        create_default_slot6,
        ({ ref }) => ({ 14: ref }),
        ({ ref }) => ref ? 16384 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t = new T({ props: t_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(t.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*obj, $$restProps*/
      24 ? get_spread_update(t_spread_levels, [
        dirty & /*obj*/
        8 && { is: (
          /*obj*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        )
      ]) : {};
      if (dirty & /*$$scope, range, $debug, ref*/
      16899) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = ["strength", "range", "gravityType", "gravitationalConstant"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $debug;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Attractor", slots, ["default"]);
  let { strength = 1 } = $$props;
  let { range = 50 } = $$props;
  let { gravityType = "static" } = $$props;
  let { gravitationalConstant = 6673e-14 } = $$props;
  const { world, debug } = useRapier();
  validate_store(debug, "debug");
  component_subscribe($$self, debug, (value) => $$invalidate(1, $debug = value));
  const gravitySource = new Vector3();
  let obj = new Group();
  const calcForceByType = {
    static: (s, m2, r, d, G) => s,
    linear: (s, m2, r, d, G) => s * (d / r),
    newtonian: (s, m2, r, d, G) => G * s * m2 / Math.pow(d, 2)
  };
  function applyImpulseToBodiesInRange() {
    const impulseVector = new Vector3();
    obj.getWorldPosition(gravitySource);
    world.forEachRigidBody((body) => {
      const { x, y, z } = body.translation();
      const bodyV3 = new Vector3(x, y, z);
      const distance = gravitySource.distanceTo(bodyV3);
      if (distance < range) {
        let force = calcForceByType[gravityType](strength, body.mass(), range, distance, gravitationalConstant);
        force = force === Infinity ? strength : force;
        impulseVector.subVectors(gravitySource, bodyV3).normalize().multiplyScalar(force);
        body.applyImpulse(impulseVector, true);
      }
    });
  }
  useFrame(() => {
    applyImpulseToBodiesInRange();
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("strength" in $$new_props)
      $$invalidate(5, strength = $$new_props.strength);
    if ("range" in $$new_props)
      $$invalidate(0, range = $$new_props.range);
    if ("gravityType" in $$new_props)
      $$invalidate(6, gravityType = $$new_props.gravityType);
    if ("gravitationalConstant" in $$new_props)
      $$invalidate(7, gravitationalConstant = $$new_props.gravitationalConstant);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useFrame,
    Group,
    Vector3,
    useRapier,
    strength,
    range,
    gravityType,
    gravitationalConstant,
    world,
    debug,
    gravitySource,
    obj,
    calcForceByType,
    applyImpulseToBodiesInRange,
    $debug
  });
  $$self.$inject_state = ($$new_props) => {
    if ("strength" in $$props)
      $$invalidate(5, strength = $$new_props.strength);
    if ("range" in $$props)
      $$invalidate(0, range = $$new_props.range);
    if ("gravityType" in $$props)
      $$invalidate(6, gravityType = $$new_props.gravityType);
    if ("gravitationalConstant" in $$props)
      $$invalidate(7, gravitationalConstant = $$new_props.gravitationalConstant);
    if ("obj" in $$props)
      $$invalidate(3, obj = $$new_props.obj);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    range,
    $debug,
    debug,
    obj,
    $$restProps,
    strength,
    gravityType,
    gravitationalConstant,
    slots,
    $$scope
  ];
}
var Attractor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      strength: 5,
      range: 0,
      gravityType: 6,
      gravitationalConstant: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Attractor",
      options,
      id: create_fragment8.name
    });
  }
  get strength() {
    throw new Error("<Attractor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strength(value) {
    throw new Error("<Attractor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get range() {
    throw new Error("<Attractor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<Attractor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gravityType() {
    throw new Error("<Attractor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gravityType(value) {
    throw new Error("<Attractor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gravitationalConstant() {
    throw new Error("<Attractor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gravitationalConstant(value) {
    throw new Error("<Attractor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Attractor_default = Attractor;

// node_modules/@threlte/rapier/dist/recipes/BasicPlayerController.svelte
var { Error: Error_1 } = globals;
function create_default_slot_5(ctx) {
  let collider;
  let current;
  collider = new Collider_default({
    props: {
      shape: "capsule",
      args: [
        /*height*/
        ctx[1] / 2 - /*radius*/
        ctx[2],
        /*radius*/
        ctx[2]
      ]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(collider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(collider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(collider, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const collider_changes = {};
      if (dirty & /*height, radius*/
      6)
        collider_changes.args = [
          /*height*/
          ctx2[1] / 2 - /*radius*/
          ctx2[2],
          /*radius*/
          ctx2[2]
        ];
      collider.$set(collider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(collider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(110:4) <CollisionGroups groups={playerCollisionGroups}>",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let collider;
  let current;
  collider = new Collider_default({
    props: {
      sensor: true,
      shape: "ball",
      args: [
        /*radius*/
        ctx[2] * 1.2
      ]
    },
    $$inline: true
  });
  collider.$on(
    "sensorenter",
    /*sensorenter_handler*/
    ctx[13]
  );
  collider.$on(
    "sensorexit",
    /*sensorexit_handler*/
    ctx[14]
  );
  const block = {
    c: function create() {
      create_component(collider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(collider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(collider, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const collider_changes = {};
      if (dirty & /*radius*/
      4)
        collider_changes.args = [
          /*radius*/
          ctx2[2] * 1.2
        ];
      collider.$set(collider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(collider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(115:6) <T.Group position={[0, -height / 2 + radius, 0]}>",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let t_group;
  let current;
  t_group = new T.Group({
    props: {
      position: [0, -/*height*/
      ctx[1] / 2 + /*radius*/
      ctx[2], 0],
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_group_changes = {};
      if (dirty & /*height, radius*/
      6)
        t_group_changes.position = [0, -/*height*/
        ctx2[1] / 2 + /*radius*/
        ctx2[2], 0];
      if (dirty & /*$$scope, radius, groundsSensored*/
      65572) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(114:4) <CollisionGroups groups={groundCollisionGroups}>",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(126:4) <T.Group position.y={-height / 2}>",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let collisiongroups0;
  let t0;
  let collisiongroups1;
  let t1;
  let t_group;
  let current;
  collisiongroups0 = new CollisionGroups_default({
    props: {
      groups: (
        /*playerCollisionGroups*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  collisiongroups1 = new CollisionGroups_default({
    props: {
      groups: (
        /*groundCollisionGroups*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  t_group = new T.Group({
    props: {
      "position.y": -/*height*/
      ctx[1] / 2,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(collisiongroups0.$$.fragment);
      t0 = space();
      create_component(collisiongroups1.$$.fragment);
      t1 = space();
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(collisiongroups0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(collisiongroups1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(collisiongroups0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(collisiongroups1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const collisiongroups0_changes = {};
      if (dirty & /*playerCollisionGroups*/
      8)
        collisiongroups0_changes.groups = /*playerCollisionGroups*/
        ctx2[3];
      if (dirty & /*$$scope, height, radius*/
      65542) {
        collisiongroups0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collisiongroups0.$set(collisiongroups0_changes);
      const collisiongroups1_changes = {};
      if (dirty & /*groundCollisionGroups*/
      16)
        collisiongroups1_changes.groups = /*groundCollisionGroups*/
        ctx2[4];
      if (dirty & /*$$scope, height, radius, groundsSensored*/
      65574) {
        collisiongroups1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collisiongroups1.$set(collisiongroups1_changes);
      const t_group_changes = {};
      if (dirty & /*height*/
      2)
        t_group_changes["position.y"] = -/*height*/
        ctx2[1] / 2;
      if (dirty & /*$$scope*/
      65536) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collisiongroups0.$$.fragment, local);
      transition_in(collisiongroups1.$$.fragment, local);
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collisiongroups0.$$.fragment, local);
      transition_out(collisiongroups1.$$.fragment, local);
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(collisiongroups0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(collisiongroups1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(104:2) <RigidBody     dominance={127}     enabledRotations={[false, false, false]}     bind:rigidBody     type={'dynamic'}   >",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let rigidbody;
  let updating_rigidBody;
  let current;
  function rigidbody_rigidBody_binding(value) {
    ctx[15](value);
  }
  let rigidbody_props = {
    dominance: 127,
    enabledRotations: [false, false, false],
    type: "dynamic",
    $$slots: { default: [create_default_slot_12] },
    $$scope: { ctx }
  };
  if (
    /*rigidBody*/
    ctx[6] !== void 0
  ) {
    rigidbody_props.rigidBody = /*rigidBody*/
    ctx[6];
  }
  rigidbody = new RigidBody_default({ props: rigidbody_props, $$inline: true });
  binding_callbacks.push(() => bind(rigidbody, "rigidBody", rigidbody_rigidBody_binding));
  const block = {
    c: function create() {
      create_component(rigidbody.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rigidbody.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rigidbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rigidbody_changes = {};
      if (dirty & /*$$scope, height, groundCollisionGroups, radius, groundsSensored, playerCollisionGroups*/
      65598) {
        rigidbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_rigidBody && dirty & /*rigidBody*/
      64) {
        updating_rigidBody = true;
        rigidbody_changes.rigidBody = /*rigidBody*/
        ctx2[6];
        add_flush_callback(() => updating_rigidBody = false);
      }
      rigidbody.$set(rigidbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rigidbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rigidbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rigidbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(103:0) <T.Group {position}>",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let t_group;
  let current;
  let mounted;
  let dispose;
  t_group = new T.Group({
    props: {
      position: (
        /*position*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "keydown", prevent_default(
            /*onKeyDown*/
            ctx[7]
          ), false, true, false, false),
          listen_dev(window, "keyup", prevent_default(
            /*onKeyUp*/
            ctx[8]
          ), false, true, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const t_group_changes = {};
      if (dirty & /*position*/
      1)
        t_group_changes.position = /*position*/
        ctx2[0];
      if (dirty & /*$$scope, rigidBody, height, groundCollisionGroups, radius, groundsSensored, playerCollisionGroups*/
      65662) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_group, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BasicPlayerController", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { height = 1.7 } = $$props;
  let { radius = 0.3 } = $$props;
  let { speed = 1 } = $$props;
  let { jumpStrength = 3 } = $$props;
  let { playerCollisionGroups = [0] } = $$props;
  let { groundCollisionGroups = [15] } = $$props;
  let rigidBody;
  const { renderer } = useThrelte();
  if (!renderer)
    throw new Error();
  const keys = {
    up: false,
    down: false,
    left: false,
    right: false
  };
  const t = new Vector3();
  const t2 = new Vector2();
  const dispatch = createRawEventDispatcher();
  let grounded = false;
  let groundsSensored = 0;
  useFrame(() => {
    if (!rigidBody)
      return;
    t.fromArray([0, 0, 0]);
    if (keys.down)
      t.x += 1;
    if (keys.up)
      t.x -= 1;
    if (keys.left)
      t.z += 1;
    if (keys.right)
      t.z -= 1;
    const l = t.length();
    const xzLength = t2.set(t.x, t.z).length();
    if (l > 0)
      t.divideScalar(l).multiplyScalar(speed);
    if (xzLength > 0) {
      rigidBody.resetForces(true);
      rigidBody.resetTorques(true);
    }
    const linVel = rigidBody.linvel();
    t.y = linVel.y;
    rigidBody.setLinvel(t, true);
  });
  const onKeyDown = (e2) => {
    switch (e2.key) {
      case "ArrowDown":
        keys.down = true;
        break;
      case "ArrowUp":
        keys.up = true;
        break;
      case "ArrowLeft":
        keys.left = true;
        break;
      case "ArrowRight":
        keys.right = true;
        break;
      case " ":
        if (!rigidBody || !grounded)
          break;
        rigidBody.applyImpulse({ x: 0, y: jumpStrength, z: 0 }, true);
      default:
        break;
    }
  };
  const onKeyUp = (e2) => {
    switch (e2.key) {
      case "ArrowDown":
        keys.down = false;
        break;
      case "ArrowUp":
        keys.up = false;
        break;
      case "ArrowLeft":
        keys.left = false;
        break;
      case "ArrowRight":
        keys.right = false;
        break;
      default:
        break;
    }
  };
  const writable_props = [
    "position",
    "height",
    "radius",
    "speed",
    "jumpStrength",
    "playerCollisionGroups",
    "groundCollisionGroups"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BasicPlayerController> was created with unknown prop '${key}'`);
  });
  const sensorenter_handler = () => $$invalidate(5, groundsSensored += 1);
  const sensorexit_handler = () => $$invalidate(5, groundsSensored -= 1);
  function rigidbody_rigidBody_binding(value) {
    rigidBody = value;
    $$invalidate(6, rigidBody);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("radius" in $$props2)
      $$invalidate(2, radius = $$props2.radius);
    if ("speed" in $$props2)
      $$invalidate(9, speed = $$props2.speed);
    if ("jumpStrength" in $$props2)
      $$invalidate(10, jumpStrength = $$props2.jumpStrength);
    if ("playerCollisionGroups" in $$props2)
      $$invalidate(3, playerCollisionGroups = $$props2.playerCollisionGroups);
    if ("groundCollisionGroups" in $$props2)
      $$invalidate(4, groundCollisionGroups = $$props2.groundCollisionGroups);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createRawEventDispatcher,
    T,
    useFrame,
    useThrelte,
    Vector2,
    Vector3,
    Collider: Collider_default,
    CollisionGroups: CollisionGroups_default,
    RigidBody: RigidBody_default,
    position,
    height,
    radius,
    speed,
    jumpStrength,
    playerCollisionGroups,
    groundCollisionGroups,
    rigidBody,
    renderer,
    keys,
    t,
    t2,
    dispatch,
    grounded,
    groundsSensored,
    onKeyDown,
    onKeyUp
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("radius" in $$props2)
      $$invalidate(2, radius = $$props2.radius);
    if ("speed" in $$props2)
      $$invalidate(9, speed = $$props2.speed);
    if ("jumpStrength" in $$props2)
      $$invalidate(10, jumpStrength = $$props2.jumpStrength);
    if ("playerCollisionGroups" in $$props2)
      $$invalidate(3, playerCollisionGroups = $$props2.playerCollisionGroups);
    if ("groundCollisionGroups" in $$props2)
      $$invalidate(4, groundCollisionGroups = $$props2.groundCollisionGroups);
    if ("rigidBody" in $$props2)
      $$invalidate(6, rigidBody = $$props2.rigidBody);
    if ("grounded" in $$props2)
      $$invalidate(11, grounded = $$props2.grounded);
    if ("groundsSensored" in $$props2)
      $$invalidate(5, groundsSensored = $$props2.groundsSensored);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*groundsSensored*/
    32) {
      $: {
        if (groundsSensored === 0)
          $$invalidate(11, grounded = false);
        else
          $$invalidate(11, grounded = true);
      }
    }
    if ($$self.$$.dirty & /*grounded*/
    2048) {
      $:
        grounded ? dispatch("groundenter") : dispatch("groundexit");
    }
  };
  return [
    position,
    height,
    radius,
    playerCollisionGroups,
    groundCollisionGroups,
    groundsSensored,
    rigidBody,
    onKeyDown,
    onKeyUp,
    speed,
    jumpStrength,
    grounded,
    slots,
    sensorenter_handler,
    sensorexit_handler,
    rigidbody_rigidBody_binding,
    $$scope
  ];
}
var BasicPlayerController = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      position: 0,
      height: 1,
      radius: 2,
      speed: 9,
      jumpStrength: 10,
      playerCollisionGroups: 3,
      groundCollisionGroups: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BasicPlayerController",
      options,
      id: create_fragment9.name
    });
  }
  get position() {
    throw new Error_1("<BasicPlayerController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error_1("<BasicPlayerController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error_1("<BasicPlayerController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error_1("<BasicPlayerController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error_1("<BasicPlayerController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error_1("<BasicPlayerController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get speed() {
    throw new Error_1("<BasicPlayerController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set speed(value) {
    throw new Error_1("<BasicPlayerController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get jumpStrength() {
    throw new Error_1("<BasicPlayerController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set jumpStrength(value) {
    throw new Error_1("<BasicPlayerController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playerCollisionGroups() {
    throw new Error_1("<BasicPlayerController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playerCollisionGroups(value) {
    throw new Error_1("<BasicPlayerController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groundCollisionGroups() {
    throw new Error_1("<BasicPlayerController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groundCollisionGroups(value) {
    throw new Error_1("<BasicPlayerController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BasicPlayerController_default = BasicPlayerController;
export {
  Attractor_default as Attractor,
  AutoColliders_default as AutoColliders,
  BasicPlayerController_default as BasicPlayerController,
  Collider_default as Collider,
  CollisionGroups_default as CollisionGroups,
  Debug_default as Debug,
  RigidBody_default as RigidBody,
  World_default as World,
  computeBitMask,
  useCollisionGroups,
  useFixedJoint,
  useJoint,
  usePrismaticJoint,
  useRapier,
  useRevoluteJoint,
  useRigidBody,
  useSphericalJoint
};
//# sourceMappingURL=@threlte_rapier.js.map
